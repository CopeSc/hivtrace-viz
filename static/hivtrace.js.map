{"version":3,"sources":["main.js","misc.js","histogram.js","clusternetwork.js","scatterplot.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzwFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hivtrace.js","sourcesContent":["var root = this;\n\nif (typeof datamonkey === 'undefined') {\n\tdatamonkey = new Object;\n}\n\ndatamonkey.hivtrace = function () {};\n\nif (typeof exports !== 'undefined') {\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = datamonkey.hivtrace;\n  }\n\n  exports.datamonkey.hivtrace = datamonkey.hivtrace;\n\n} else {\n\n  root.datamonkey.hivtrace = datamonkey.hivtrace;\n\n}\n","//_ = require('underscore');\n\nfunction hivtrace_cluster_adjacency_list(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    var adjacency_list = {};\n\n    edges.forEach(function(e, i) {\n\n        function in_nodes(n, id) {\n            return n.id == id;\n        }\n\n        var seq_ids = e[\"sequences\"];\n\n        var n1 = nodes.filter(function(n) {\n                return in_nodes(n, seq_ids[0])\n            })[0],\n            n2 = nodes.filter(function(n) {\n                return in_nodes(n, seq_ids[1])\n            })[0];\n\n        adjacency_list[n1.id] ? adjacency_list[n1.id].push(n2) : adjacency_list[n1.id] = [n2];\n        adjacency_list[n2.id] ? adjacency_list[n2.id].push(n1) : adjacency_list[n2.id] = [n1];\n\n    });\n\n\n    return adjacency_list;\n\n}\n\nhivtrace_generate_svg_polygon_lookup = {\n};\n\n_.each (_.range (3,20), function (d) {\n    var angle_step    = Math.PI*2/d;\n    hivtrace_generate_svg_polygon_lookup [d] = _.map (_.range (1,d), function (i) {\n        return [Math.cos (angle_step * i), Math.sin (angle_step * i)];\n    });\n});\n\nfunction hivtrace_generate_svg_symbol (type) {\n    switch (type) {\n        case 'circle':\n        case 'cross':\n        case 'diamond':\n        case 'square':\n        case 'triangle-down':\n        case 'triangle-up':\n            return  d3.svg.symbol().type (type);\n\n        case 'pentagon':\n            return hivtrace_generate_svg_polygon().sides (5);\n        case 'hexagon':\n            return hivtrace_generate_svg_polygon().sides (6);\n        case 'septagon':\n            return hivtrace_generate_svg_polygon().sides (7);\n        case 'octagon':\n            return hivtrace_generate_svg_polygon().sides (8);\n    }\n    return node;\n}\n\nfunction hivtrace_generate_svg_polygon () {\n    var self = this;\n\n\n    function polygon () {\n        var path  = \" M\" + self.radius + \" 0\";\n\n        if (self.sides in hivtrace_generate_svg_polygon_lookup) {\n             path += hivtrace_generate_svg_polygon_lookup[self.sides].map (function (value) {\n                return \" L\" + self.radius * value[0] + \" \" + self.radius * value[1];\n             }).join (\" \");\n        } else {\n            var angle_step    = Math.PI*2/self.sides,\n                current_angle = 0;\n            for (i = 0; i < self.sides - 1; i++) {\n                current_angle += angle_step;\n                path += \" L\" + self.radius * Math.cos (current_angle) + \" \" + self.radius * Math.sin (current_angle);\n            }\n        }\n\n        path += \" Z\";\n        return path;\n    }\n\n    polygon.sides = function (attr) {\n        if (_.isNumber (attr) && attr > 2) {\n            self.sides = attr;\n            return polygon;\n        }\n        return self.sides;\n    }\n\n    polygon.type = function () {\n       return polygon;\n    }\n\n    polygon.size = function(attr) {\n        if (_.isNumber (attr)) {\n            self.size = attr;\n            self.radius = Math.sqrt (attr/Math.PI);\n            return polygon;\n        }\n        return self.size;\n    }\n\n    polygon.size (64);\n    self.sides  = 6;\n\n    return polygon;\n}\n\nfunction hivtrace_new_cluster_adjacency_list(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    nodes.forEach (function (n) {\n        n.neighbors = d3.set();\n    });\n\n    edges.forEach (function (e) {\n        nodes[e.source].neighbors.add(e.target);\n        nodes[e.target].neighbors.add(e.source);\n    });\n\n}\n\n// Reconstructs path from floyd-warshall algorithm\nfunction hivtrace_get_path(next, i, j) {\n\n    var all_paths = [];\n    var i = parseInt(i);\n    var j = parseInt(j);\n\n    for (var c = 0; c < next[i][j].length; c++) {\n\n        var k = next[i][j][c];\n        var intermediate = k;\n\n        if (intermediate == null || intermediate == i) {\n            return [\n                [parseInt(i), parseInt(j)]\n            ];\n        } else {\n\n            var paths_i_k = hivtrace_get_path(next, i, intermediate);\n            var paths_k_j = hivtrace_get_path(next, intermediate, j);\n\n            for (var i_k_index = 0; i_k_index < paths_i_k.length; i_k_index++) {\n                var i_k = paths_i_k[i_k_index];\n                for (var k_j_index = 0; k_j_index < paths_k_j.length; k_j_index++) {\n                    var k_j = paths_k_j[k_j_index];\n                    if (i_k.length) {\n                        if ((i_k[0] == i) && (i_k[i_k.length - 1] == k) && (k_j[0] == k) && (k_j[k_j.length - 1] == j)) {\n                            i_k.pop()\n                            all_paths.push(i_k.concat(k_j));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return all_paths;\n\n}\n\nfunction hivtrace_paths_with_node(node, next, i, j) {\n\n    var paths = hivtrace_get_path(next, i, j);\n\n    // Retrieve intermediary paths\n    paths = paths.map(function(sublist) {\n        return sublist.slice(1, -1)\n    });\n\n    if (!paths) {\n        return 0;\n    }\n\n    var num_nodes = [];\n\n    for (var i = 0; i < paths.length; i++) {\n        sublist = paths[i];\n        num_nodes.push(d3.sum(sublist.map(function(n) {\n            return n == node;\n        })));\n    }\n\n    var mean = d3.mean(num_nodes);\n\n    if (mean == undefined) {\n        mean = 0;\n    }\n\n    return mean;\n\n}\n\n\n// Same as compute shortest paths, but with an additional next parameter for reconstruction\nfunction hivtrace_compute_shortest_paths_with_reconstruction(obj, subset, use_actual_distances) {\n\n    // Floyd-Warshall implementation\n    var distances = [];\n    var next = [];\n    var nodes = obj.Nodes;\n    var edges = obj.Edges;\n    var node_ids = [];\n\n    var adjacency_list = datamonkey.hivtrace.cluster_adjacency_list(obj);\n\n    if (!subset) {\n        subset = Object.keys(adjacency_list);\n    }\n\n    var node_count = subset.length;\n\n    for (var i = 0; i < subset.length; i++) {\n        var a_node = subset[i];\n        var empty_arr = _.range(node_count).map(function(d) {\n            return null\n        });\n        var zeroes = _.range(node_count).map(function(d) {\n            return null\n        });\n        distances.push(zeroes);\n        next.push(empty_arr);\n    };\n\n    for (var index = 0; index < subset.length; index++) {\n        var a_node = subset[index];\n        for (var index2 = 0; index2 < subset.length; index2++) {\n            var second_node = subset[index2];\n            if (second_node != a_node) {\n                if (adjacency_list[a_node].map(function(n) {\n                        return n.id\n                    }).indexOf(second_node) != -1) {\n                    distances[index][index2] = 1;\n                    distances[index2][index] = 1;\n                }\n            }\n        }\n    }\n\n    for (var index_i = 0; index_i < subset.length; index_i++) {\n        var n_i = subset[index_i];\n        for (var index_j = 0; index_j < subset.length; index_j++) {\n            var n_j = subset[index_j];\n            if (index_i == index_j) {\n                next[index_i][index_j] = [];\n            } else {\n                next[index_i][index_j] = [index_i];\n            }\n        }\n    }\n\n    // clone distances\n    var distances2 = _.map(distances, _.clone);\n    var c = 0;\n\n    for (var index_k = 0; index_k < subset.length; index_k++) {\n        var n_k = subset[index_k];\n        for (var index_i = 0; index_i < subset.length; index_i++) {\n            var n_i = subset[index_i];\n            for (var index_j = 0; index_j < subset.length; index_j++) {\n                var n_j = subset[index_j];\n\n                if (n_i != n_j) {\n\n                    d_ik = distances[index_k][index_i];\n                    d_jk = distances[index_k][index_j];\n                    d_ij = distances[index_i][index_j];\n\n                    if (d_ik != null && d_jk != null) {\n                        d_ik += d_jk;\n                        if (d_ij == null || (d_ij > d_ik)) {\n                            distances2[index_i][index_j] = d_ik;\n                            distances2[index_j][index_i] = d_ik;\n                            next[index_i][index_j] = [];\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\n                            continue;\n                        } else if (d_ij == d_ik) {\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\n                        }\n                    }\n                    c++;\n                    distances2[index_j][index_i] = distances[index_j][index_i];\n                    distances2[index_i][index_j] = distances[index_i][index_j];\n                }\n            }\n        }\n\n        var t = distances2;\n        distances2 = distances;\n        distances = t;\n\n    }\n\n    return {\n        'ordering': subset,\n        'distances': distances,\n        'next': next\n    };\n\n}\n\nfunction hivtrace_filter_to_node_in_cluster(node, obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges,\n        cluster_id = null;\n\n    // Retrieve nodes that are part of the cluster\n    var node_obj = nodes.filter(function(n) {\n        return node == n.id;\n    });\n\n    if (node_obj) {\n        cluster_id = node_obj[0].cluster;\n    } else {\n        console.log('could not find node');\n        return null;\n    }\n\n    // Filter out all edges and nodes that belong to the cluster\n    var nodes_in_cluster = nodes.filter(function(n) {\n        return cluster_id == n.cluster;\n    });\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n    var edges_in_cluster = edges.filter(function(e) {\n        return node_ids.indexOf(e.sequences[0]) != -1\n    });\n\n    var filtered_obj = {};\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\n    filtered_obj[\"Edges\"] = edges_in_cluster;\n    return filtered_obj;\n\n}\n\nfunction hivtrace_compute_betweenness_centrality_all_nodes_in_cluster(cluster, obj, cb) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    var nodes_in_cluster = nodes.filter(function(n) {\n        return cluster == n.cluster;\n    });\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n    var edges_in_cluster = edges.filter(function(e) {\n        return node_ids.indexOf(e.sequences[0]) != -1\n    });\n\n    var filtered_obj = {};\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\n    filtered_obj[\"Edges\"] = edges_in_cluster;\n\n    // get length of cluster\n    if (nodes_in_cluster.length > 70) {\n        cb('cluster too large', null);\n        return;\n    }\n\n    // get paths\n    var paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n\n    var betweenness = {}\n    nodes_in_cluster.forEach(function(n) {\n        betweenness[n.id] = hivtrace_compute_betweenness_centrality(n.id, filtered_obj, paths);\n    });\n\n    cb(null, betweenness);\n    return;\n\n}\n\n// Returns dictionary of nodes' betweenness centrality\n// Utilizes the Floyd-Warshall Algorithm with reconstruction\nfunction hivtrace_compute_betweenness_centrality(node, obj, paths) {\n\n    if (!paths) {\n        var filtered_obj = hivtrace_filter_to_node_in_cluster(node, obj)\n        paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\n    }\n\n    // find index of id\n    var index = paths['ordering'].indexOf(node);\n\n    if (index == -1) {\n        return null;\n    }\n\n    var length = paths['distances'].length;\n\n    if (length != 2) {\n        scale = 1 / ((length - 1) * (length - 2));\n    } else {\n        scale = 1;\n    }\n\n\n    // If s->t goes through 1, add to sum\n    // Reconstruct each shortest path and check if node is in it\n    var paths_with_node = [];\n    for (i in _.range(length)) {\n        for (j in _.range(length)) {\n            paths_with_node.push(hivtrace_paths_with_node(index, paths['next'], i, j));\n        }\n    }\n\n    return d3.sum(paths_with_node) * scale;\n\n}\n\n\nfunction hivtrace_compute_node_degrees(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n    for (var n in nodes) {\n        nodes[n].degree = 0;\n    }\n\n    for (var e in edges) {\n        nodes[edges[e].source].degree++;\n        nodes[edges[e].target].degree++;\n    }\n\n}\n\nfunction hivtrace_get_node_by_id(id, obj) {\n    return obj.Nodes.filter(function(n) {\n        return id == n.id\n    })[0] || undefined;\n}\n\nfunction hivtrace_compute_cluster_betweenness(obj, callback) {\n\n    var nodes = obj.Nodes;\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    // Get all unique clusters\n    var clusters = nodes.map(function(n) {\n        return n.cluster\n    });\n    var unique_clusters = clusters.filter(onlyUnique);\n\n    var cb_count = 0;\n\n    function cb(err, results) {\n\n        cb_count++;\n\n        for (node in results) {\n            hivtrace_get_node_by_id(node, obj)['betweenness'] = results[node];\n        }\n\n        if (cb_count >= unique_clusters.length) {\n            callback('done');\n        }\n\n    }\n\n    // Compute betweenness in parallel\n    unique_clusters.forEach(function(cluster_id) {\n        datamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster(cluster_id, obj, cb);\n    });\n\n    // once all settled callback\n\n}\n\n\nfunction hivtrace_is_contaminant(node) {\n    return node.attributes.indexOf('problematic') != -1;\n}\n\nfunction hivtrace_convert_to_csv(obj, callback) {\n    //Translate nodes to rows, and then use d3.format\n    hivtrace_compute_node_degrees(obj);\n\n    hivtrace_compute_cluster_betweenness(obj, function(err) {\n        var node_array = obj.Nodes.map(function(d) {\n            return [d.id, d.cluster, d.degree, d.betweenness, hivtrace_is_contaminant(d), d.attributes.join(';')]\n        });\n        node_array.unshift(['seqid', 'cluster', 'degree', 'betweenness', 'is_contaminant', 'attributes'])\n        node_csv = d3.csv.format(node_array);\n        callback(null, node_csv);\n    });\n}\n\nfunction hivtrace_export_csv_button(graph, tag) {\n\n    var data = hivtrace_convert_to_csv(graph, function(err, data) {\n        if (data != null) {\n            var pom = document.createElement('a');\n            pom.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(data));\n            pom.setAttribute('download', 'export.csv');\n            pom.className = 'btn btn-default btn-sm';\n            pom.innerHTML = '<span class=\"glyphicon glyphicon-floppy-save\"></span> Export Results';\n            $(tag).append(pom);\n        }\n    });\n\n}\n\nfunction hiv_trace_export_table_to_text(parent_id, table_id, sep) {\n\n    var the_button = d3.select(parent_id).append(\"a\")\n        .attr(\"target\", \"_blank\")\n        .on(\"click\", function(data, element) {\n            var table_tag = d3.select(this).attr(\"data-table\");\n            var table_text = datamonkey.helpers.table_to_text(table_tag);\n            datamonkey.helpers.export_handler(table_text, table_tag.substring(1) + \".tsv\", \"text/tab-separated-values\");\n        })\n        .attr(\"data-table\", table_id);\n\n    the_button.append(\"i\").classed(\"fa fa-download fa-2x\", true);\n    return the_button;\n\n}\n\nhivtrace_compute_local_clustering_coefficients = _.once (function (obj) {\n\n  datamonkey.hivtrace.new_cluster_adjacency_list(obj);\n\n  var nodes = obj.Nodes;\n\n  nodes.forEach (function (n) {\n\n    var a_node = n;\n    var neighborhood_size = a_node.neighbors.size();\n\n    if (neighborhood_size < 2) {\n        a_node.lcc = undefined;\n    } else {\n\n        if (neighborhood_size > 500) {\n            a_node.lcc = datamonkey.hivtrace.too_large;\n        } else {\n            // count triangles\n            neighborhood = a_node.neighbors.values();\n            counter = 0;\n            for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\n                for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\n                    if (nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\n                        counter ++;\n                    }\n                }\n            }\n            a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\n        }\n    }\n\n  });\n\n});\n\nfunction hivtrace_render_settings(settings, explanations) {\n    // TODO:\n    //d3.json (explanations, function (error, expl) {\n    //    //console.log (settings);\n    //});\n}\n\nfunction hivtrace_format_value(value, formatter) {\n\n    if (typeof value === 'undefined') {\n        return \"Not computed\";\n    }\n    if (value === datamonkey.hivtrace.undefined) {\n        return \"Undefined\";\n    }\n    if (value === datamonkey.hivtrace.too_large) {\n        return \"Size limit\";\n    }\n\n    if (value === datamonkey.hivtrace.processing) {\n        return '<span class=\"fa fa-spin fa-spinner\"></span>';\n    }\n\n    return formatter ? formatter(value) : value;\n\n}\n\n\nif (typeof datamonkey == 'undefined') {\n    datamonkey = function() {};\n}\n\nif (typeof datamonkey.hivtrace == 'undefined') {\n    datamonkey.hivtrace = function() {};\n}\n\ndatamonkey.hivtrace.compute_node_degrees = hivtrace_compute_node_degrees;\ndatamonkey.hivtrace.export_csv_button = hivtrace_export_csv_button;\ndatamonkey.hivtrace.convert_to_csv = hivtrace_convert_to_csv;\ndatamonkey.hivtrace.betweenness_centrality = hivtrace_compute_betweenness_centrality;\ndatamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster = hivtrace_compute_betweenness_centrality_all_nodes_in_cluster;\ndatamonkey.hivtrace.cluster_adjacency_list = hivtrace_cluster_adjacency_list;\ndatamonkey.hivtrace.new_cluster_adjacency_list = hivtrace_new_cluster_adjacency_list;\ndatamonkey.hivtrace.analysis_settings = hivtrace_render_settings;\ndatamonkey.hivtrace.export_table_to_text = hiv_trace_export_table_to_text;\ndatamonkey.hivtrace.compute_local_clustering = hivtrace_compute_local_clustering_coefficients;\ndatamonkey.hivtrace.undefined = new Object();\ndatamonkey.hivtrace.too_large = new Object();\ndatamonkey.hivtrace.processing = new Object();\ndatamonkey.hivtrace.format_value = hivtrace_format_value;\ndatamonkey.hivtrace.polygon    = hivtrace_generate_svg_polygon;\ndatamonkey.hivtrace.symbol    = hivtrace_generate_svg_symbol;\n","function hivtrace_histogram(graph, histogram_tag, histogram_label) {  \n\n  var defaultFloatFormat = d3.format(\",.2f\");\n  var histogram_w = 300,\n  histogram_h = 300;\n\n  hivtrace_render_histogram(graph[\"Degrees\"][\"Distribution\"], \n                            graph[\"Degrees\"][\"fitted\"], \n                            histogram_w, \n                            histogram_h, \n                            histogram_tag);\n                            \n  var label = \"Network degree distribution is best described by the <strong>\" + graph[\"Degrees\"][\"Model\"] + \"</strong> model, with &rho; of \" + \n             defaultFloatFormat(graph[\"Degrees\"][\"rho\"]);\n             \n  if (graph[\"Degrees\"][\"rho CI\"] != undefined) {\n        label += \" (95% CI \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][0]) + \" - \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][1]) + \")\";\n  }\n\n  d3.select (histogram_label).html(label);\n}\n\nfunction hivtrace_histogram_distances (graph, histogram_tag, histogram_label) {  \n\n  var defaultFloatFormat = d3.format(\",.3p\");\n  var histogram_w = 300,\n  histogram_h = 300;\n\n  var edge_lengths = _.map (graph[\"Edges\"], function (edge) {return edge.length;});\n  \n\n  hivtrace_render_histogram_continuous(edge_lengths, \n                            histogram_w, \n                            histogram_h, \n                            histogram_tag);\n                            \n  var label = \"Genetic distances among linked nodes.\";\n  d3.select (histogram_label).html(label);\n}\n\nfunction hivtrace_render_histogram_continuous (data, w, h, id) {\n\n\tvar margin = {top: 10, right: 30, bottom: 50, left: 30},\n\t\t\t\twidth = w - margin.left - margin.right,\n\t\t\t\theight = h - margin.top - margin.bottom;\n\n\n    var histogram_data = d3.layout.histogram()(data);\n\n\n\n\tvar x = d3.scale.linear()\n\t\t\t.domain(d3.extent (data))\n\t\t\t.range([0, width]);\n\t\t\n\tvar y = d3.scale.linear ()\n\t\t\t.domain ([0, d3.max (_.map (histogram_data, function (b) {return b.y}))])\n\t\t\t.range  ([height,0]); \n\t\t\n\t\n\tvar xAxis = d3.svg.axis()\n\t\t.scale(x)\n\t\t.orient(\"bottom\");\n\n\tvar yAxis = d3.svg.axis()\n\t\t.scale(y)\n\t\t.orient(\"left\");\n\t\t\n\tvar histogram_svg = d3.select(id).selectAll(\"svg\");\n\n\tif (histogram_svg) {\n\t\thistogram_svg.remove();\n\t}\n\n\thistogram_data.splice (0, 0, {'x' : x.domain ()[0], 'y' : 0, 'dx' : 0});\n\thistogram_data.splice (histogram_data.length, 0, {'x' : x.domain ()[1], 'y' : 0, 'dx' : 0});\n\n\thistogram_svg = d3.select(id).insert(\"svg\",\".histogram-label\")\n\t\t\t\t\t.attr(\"width\", width + margin.left + margin.right)\n\t\t\t\t\t.attr(\"height\", height + margin.top + margin.bottom)\n\t\t\t\t\t.append(\"g\")\n\t\t\t\t\t.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\n\t\t\t\t\t.datum (histogram_data);\n\t\n\tvar histogram_line = d3.svg.line()\n\t\t\t\t\t\t.x(function(d) { return x(d.x+d.dx); })\n\t\t\t\t\t\t.y(function(d) { return y(d.y); })\n\t\t\t\t\t\t.interpolate(\"step-before\");\n\t\t\t\t\t\n\thistogram_svg.selectAll (\"path\").remove();\n\thistogram_svg.append (\"path\")\n\t\t\t\t .attr (\"d\", function(d) { return histogram_line(d) + \"Z\"; })\n\t\t\t\t .attr (\"class\", \"histogram\");\n\n  \n\n\tvar x_axis = histogram_svg.append(\"g\")\n\t\t.attr(\"class\", \"x axis\")\n\t\t.attr(\"transform\", \"translate(0,\" + height + \")\")\n\t\t.call(xAxis);    \n\t\n\tx_axis.selectAll (\"text\").attr (\"transform\", \"rotate(45)\").attr(\"dx\",\"1em\").attr(\"dy\",\"0.5em\");\n\n\tvar y_axis = histogram_svg.append(\"g\")\n\t\t.attr(\"class\", \"y axis\")\n\t\t//.attr(\"transform\", \"translate(0,\" + height + \")\")\n\t\t.call(yAxis);    \n\t\n}\n\n\nfunction hivtrace_render_histogram(counts, fit, w, h, id) {\n\n\tvar margin = {top: 10, right: 30, bottom: 50, left: 30},\n\t\t\t\twidth = w - margin.left - margin.right,\n\t\t\t\theight = h - margin.top - margin.bottom;\n\n\tvar x = d3.scale.linear()\n\t\t\t.domain([0, counts.length+1])\n\t\t\t.range([0, width]);\n\t\t\n\tvar y = d3.scale.log()\n\t\t\t.domain ([1, d3.max (counts)])\n\t\t\t.range  ([height,0]);\n\t\t\n\tvar total = d3.sum(counts);\n\n\tvar xAxis = d3.svg.axis()\n\t\t.scale(x)\n\t\t.orient(\"bottom\");\n\t\n\tvar histogram_svg = d3.select(id).selectAll(\"svg\");\n\n\tif (histogram_svg) {\n\t\thistogram_svg.remove();\n\t}\n\n\tvar data_to_plot = counts.map (function (d, i) {return {'x' : i+1, 'y' : d+1};});\n\tdata_to_plot.push ({'x' : counts.length+1, 'y' : 1});\n\tdata_to_plot.push ({'x' : 0, 'y' : 1});\n\tdata_to_plot.push ({'x' : 0, 'y' : counts[0]+1});\n\n\thistogram_svg = d3.select(id).insert(\"svg\",\".histogram-label\")\n\t.attr(\"width\", width + margin.left + margin.right)\n\t.attr(\"height\", height + margin.top + margin.bottom)\n\t.append(\"g\")\n\t.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\n\t.datum (data_to_plot);\n\t\n\tvar histogram_line = d3.svg.line()\n\t\t\t\t\t\t.x(function(d) { return x(d.x); })\n\t\t\t\t\t\t.y(function(d) { return y(d.y); })\n\t\t\t\t\t\t.interpolate(\"step-before\");\n\t\t\t\t\t\n\thistogram_svg.selectAll (\"path\").remove();\n\thistogram_svg.append (\"path\")\n\t\t\t\t .attr (\"d\", function(d) { return histogram_line(d) + \"Z\"; })\n\t\t\t\t .attr (\"class\", \"histogram\");\n\n  \n\n\t  if (fit) {    \n\t\t  var fit_line = d3.svg.line()\n\t\t\t  .interpolate(\"linear\")\n\t\t\t  .x(function(d,i) { return x(i+1) + (x(i+1)-x(i))/2; })\n\t\t\t  .y(function(d) { return y(1+d*total); });\n\t\t  histogram_svg.append(\"path\").datum(fit)\n\t\t\t.attr(\"class\", \"line\")\n\t\t\t.attr(\"d\", function(d) { return fit_line(d); });\n\t  }\n\n\tvar x_axis = histogram_svg.append(\"g\")\n\t\t.attr(\"class\", \"x axis\")\n\t\t.attr(\"transform\", \"translate(0,\" + height + \")\")\n\t\t.call(xAxis);    \n\t\n\tx_axis.selectAll (\"text\").attr (\"transform\", \"rotate(45)\").attr(\"dx\",\"1em\").attr(\"dy\",\"0.5em\");\n}\n\ndatamonkey.hivtrace.histogram = hivtrace_histogram;\ndatamonkey.hivtrace.histogram_distances = hivtrace_histogram_distances;\n","var _networkGraphAttrbuteID = \"patient_attribute_schema\";\nvar _networkNodeAttributeID = \"patient_attributes\";\nvar _networkMissing = 'missing';\nvar _networkMissingOpacity = '0.1';\nvar _networkMissingColor = '#999';\nvar _networkContinuousColorStops = 9;\nvar _networkShapeOrdering = ['circle', 'square', 'hexagon', 'diamond', 'cross', 'octagon'];\nvar _defaultFloatFormat = d3.format(\",.2r\");\nvar _defaultPercentFormat = d3.format(\",.3p\");\nvar _defaultDateFormat = d3.time.format(\"%Y-%m-%dT%H:%M:%S.%LZ\");\nvar _networkSequentialColor = {\n  3: [\"#ffeda0\", \"#feb24c\", \"#f03b20\"],\n  4: [\"#ffffb2\", \"#fecc5c\", \"#fd8d3c\", \"#e31a1c\"],\n  5: [\"#ffffb2\", \"#fecc5c\", \"#fd8d3c\", \"#f03b20\", \"#bd0026\"],\n  6: [\"#ffffb2\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#f03b20\", \"#bd0026\"],\n  7: [\"#ffffb2\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#b10026\"],\n  8: [\"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#b10026\"],\n  9: [\"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#bd0026\", \"#800026\"]\n};\n\nvar _is_CDC_ = true;\n\nvar _networkPresetColorSchemes = {\n  'trans_categ': {\n    'Other-Male': '#999999',\n    'Heterosexual Contact-Male': '#e31a1c',\n    'Other-Child': '#ff7f00',\n    'Perinatal': '#ff7f00',\n    'MSM': '#1f78b4',\n    'IDU-Male': '#33a02c',\n    'Other-Female': '#999999',\n    'IDU-Female': '#33a02c',\n    'MSM & IDU': '#33a02c',\n    'Missing': '#999999',\n    'Heterosexual Contact-Female': '#e31a1c'\n  }\n};\n\nvar hivtrace_cluster_network_graph = function(json, network_container, network_status_string, network_warning_tag, button_bar_ui, attributes, filter_edges_toggle, clusters_table, nodes_table, parent_container, options) {\n\n  // [REQ] json                        :          the JSON object containing network nodes, edges, and meta-information\n  // [REQ] network_container           :          the CSS selector of the DOM element where the SVG containing the network will be placed (e.g. '#element')\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\n  // [OPT] network_warning_tag         :          the CSS selector of the DOM element where the any warning messages would go (e.g. '#element')\n  // [OPT] button_bar_ui               :          the ID of the control bar which can contain the following elements (prefix = button_bar_ui value)\n  //                                                - [prefix]_cluster_operations_container : a drop-down for operations on clusters\n  //                                                - [prefix]_attributes :  a drop-down for operations on attributes\n  //                                                - [prefix]_filter : a text box used to search the graph\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\n  // [OPT] attributes                  :          A JSON object with mapped node attributes\n\n  var _networkPredefinedAttributeTransforms = {\n    'binned_vl_recent_value': {\n      'depends': 'vl_recent_value',\n      'label': 'binned_vl_recent_value',\n      'enum': [\"≤200\", \"200-10000\", \">10000\"],\n      'color_scale': function() {\n        return d3.scale.ordinal()\n          .domain([\"≤200\", \"200-10000\", \">10000\", _networkMissing])\n          .range(_.union(_networkSequentialColor[3], [_networkMissingColor]))\n      },\n\n      'map': function(node) {\n        var vl_value = attribute_node_value_by_id(node, 'vl_recent_value');\n        if (vl_value != _networkMissing) {\n          if (vl_value <= 200) {\n            return \"≤200\";\n          }\n          if (vl_value <= 10000) {\n            return \"200-10000\";\n          }\n          return \">10000\";\n        }\n        return _networkMissing;\n      }\n    },\n    'hiv_aids_dx_dt_year': {\n      'depends': 'hiv_aids_dx_dt',\n      'label': 'hiv_aids_dx_dt_year',\n      'type': \"String\",\n      'map': function(node) {\n        var value = _defaultDateFormat.parse(attribute_node_value_by_id(node, 'hiv_aids_dx_dt'));\n        if (value) {\n          value = \"\" + value.getFullYear();\n        } else {\n          value = _networkMissing;\n        }\n        return value;\n      },\n      'color_scale': function(attr) {\n        var range_without_missing = _.without(attr.value_range, _networkMissing);\n        var color_scale = _.compose(d3.interpolateRgb(\"#ffffcc\", \"#800026\"), d3.scale.linear().domain([range_without_missing[0], range_without_missing[range_without_missing.length - 1]]).range([0, 1]));\n        return function(v) {\n          if (v == _networkMissing) {\n            return _networkMissingColor;\n          }\n          return color_scale(v);\n        }\n      }\n    }\n  };\n\n  var old_to_new_map = {\n    \"categorical\" : \"String\",\n    \"temporal\" : \"Date\"\n  }\n\n  // Transform patient_attribute_schema types\n  _.each(json[_networkGraphAttrbuteID], function(d) { \n\n      if(_.contains(_.keys(old_to_new_map), d[\"type\"])) {\n        d[\"type\"] = old_to_new_map[d[\"type\"]];\n      }\n\n      return d;\n  });\n\n  var self = new Object;\n\n  self.ww = options && options[\"width\"] ? options[\"width\"] : d3.select(parent_container).property(\"clientWidth\");\n  self.container = network_container;\n  self.nodes = [];\n  self.edges = [];\n  self.clusters = [];\n  self.cluster_sizes = [];\n  self.colorizer = {\n    'selected': function(d) {\n      return d == 'selected' ? d3.rgb(51, 122, 183) : '#FFF'\n    }\n  };\n  self.node_shaper = {\n    'id': null,\n    'shaper': function() {\n      return 'circle'\n    }\n  };\n  self.filter_edges = true,\n    self.hide_hxb2 = false,\n    self.charge_correction = 5,\n    self.margin = {\n      top: 20,\n      right: 10,\n      bottom: 30,\n      left: 10\n    },\n    self.width = self.ww - self.margin.left - self.margin.right,\n    self.height = self.width * 9 / 16,\n    self.cluster_table = d3.select(clusters_table),\n    self.node_table = d3.select(nodes_table),\n    self.needs_an_update = false,\n    self.json = json,\n    self.gradient_id = 0;\n\n  var cluster_mapping = {},\n    l_scale = 5000, // link scale\n    graph_data = self.json, // the raw JSON network object\n    max_points_to_render = 500,\n    warning_string = \"\",\n    singletons = 0,\n    open_cluster_queue = [],\n    currently_displayed_objects,\n    gravity_scale = d3.scale.pow().exponent(0.5).domain([1, 100000]).range([0.1, 0.15]);\n\n  /*------------ D3 globals and SVG elements ---------------*/\n\n  var network_layout = d3.layout.force()\n    .on(\"tick\", tick)\n    .charge(function(d) {\n      if (d.cluster_id) return self.charge_correction * (-20 - 5 * Math.pow(d.children.length, 0.7));\n      return self.charge_correction * (-5 - 20 * Math.sqrt(d.degree));\n    })\n    .linkDistance(function(d) {\n      return Math.max(d.length, 0.005) * l_scale;\n    })\n    .linkStrength(function(d) {\n      if (d.support != undefined) {\n        return 2 * (0.5 - d.support);\n      }\n      return 1;\n    })\n    .chargeDistance(l_scale * 0.25)\n    .gravity(gravity_scale(json.Nodes.length))\n    .friction(0.25);\n\n  d3.select(network_container).selectAll(\".my_progress\").remove();\n\n\n  d3.select(network_container).selectAll(\"svg\").remove();\n  self.node_table.selectAll(\"*\").remove();\n  self.cluster_table.selectAll(\"*\").remove();\n\n  var network_svg = d3.select(network_container).append(\"svg:svg\")\n    //.style (\"border\", \"solid black 1px\")\n    .attr(\"id\", \"network-svg\")\n    .attr(\"width\", self.width + self.margin.left + self.margin.right)\n    .attr(\"height\", self.height + self.margin.top + self.margin.bottom);\n\n  //.append(\"g\")\n  // .attr(\"transform\", \"translate(\" + self.margin.left + \",\" + self.margin.top + \")\");\n\n  var legend_svg = network_svg.append(\"g\").attr(\"transform\", \"translate(5,5)\");\n\n  network_svg.append(\"defs\").append(\"marker\")\n    .attr(\"id\", \"arrowhead\")\n    .attr(\"refX\", 9) /* there must be a smarter way to calculate shift*/\n    .attr(\"refY\", 2)\n    .attr(\"markerWidth\", 6)\n    .attr(\"markerHeight\", 4)\n    .attr(\"orient\", \"auto\")\n    .attr(\"stroke\", \"#666666\")\n    .attr(\"fill\", \"#AAAAAA\")\n    .append(\"path\")\n    .attr(\"d\", \"M 0,0 V 4 L6,2 Z\"); //this is actual shape for arrowhead\n\n\n  change_window_size();\n\n\n  /*------------ Network layout code ---------------*/\n  var handle_cluster_click = function(cluster, release) {\n\n    var container = d3.select(network_container);\n    var id = \"d3_context_menu_id\";\n    var menu_object = container.select(\"#\" + id);\n\n    if (menu_object.empty()) {\n      menu_object = container.append(\"ul\")\n        .attr(\"id\", id)\n        .attr(\"class\", \"dropdown-menu\")\n        .attr(\"role\", \"menu\");\n    }\n\n    menu_object.selectAll(\"li\").remove();\n\n    var already_fixed = cluster && cluster.fixed == 1;\n\n\n    if (cluster) {\n      menu_object.append(\"li\").append(\"a\")\n        .attr(\"tabindex\", \"-1\")\n        .text(\"Expand cluster\")\n        .on(\"click\", function(d) {\n          cluster.fixed = 0;\n          expand_cluster_handler(cluster, true);\n          menu_object.style(\"display\", \"none\");\n        });\n\n      menu_object.append(\"li\").append(\"a\")\n        .attr(\"tabindex\", \"-1\")\n        .text(\"Center on screen\")\n        .on(\"click\", function(d) {\n          cluster.fixed = 0;\n          center_cluster_handler(cluster);\n          menu_object.style(\"display\", \"none\");\n        });\n\n      menu_object.append(\"li\").append(\"a\")\n        .attr(\"tabindex\", \"-1\")\n        .text(function(d) {\n          if (cluster.fixed) return \"Allow cluster to float\";\n          return \"Hold cluster at current position\";\n        })\n        .on(\"click\", function(d) {\n          cluster.fixed = !cluster.fixed;\n          menu_object.style(\"display\", \"none\");\n        });\n\n      cluster.fixed = 1;\n\n      menu_object.style(\"position\", \"absolute\")\n        .style(\"left\", \"\" + d3.event.offsetX + \"px\")\n        .style(\"top\", \"\" + d3.event.offsetY + \"px\")\n        .style(\"display\", \"block\");\n\n    } else {\n      if (release) {\n        release.fixed = 0;\n      }\n      menu_object.style(\"display\", \"none\");\n    }\n\n    container.on(\"click\", function(d) {\n      handle_cluster_click(null, already_fixed ? null : cluster);\n    }, true);\n\n  };\n\n  var handle_node_click = function(node) {\n    var container = d3.select(network_container);\n    var id = \"d3_context_menu_id\";\n    var menu_object = container.select(\"#\" + id);\n\n    if (menu_object.empty()) {\n      menu_object = container.append(\"ul\")\n        .attr(\"id\", id)\n        .attr(\"class\", \"dropdown-menu\")\n        .attr(\"role\", \"menu\");\n    }\n\n    menu_object.selectAll(\"li\").remove();\n\n    if (node) {\n      node.fixed = 1;\n      menu_object.append(\"li\").append(\"a\")\n        .attr(\"tabindex\", \"-1\")\n        .text(\"Collapse cluster\")\n        .on(\"click\", function(d) {\n          node.fixed = 0;\n          collapse_cluster_handler(node, true)\n          menu_object.style(\"display\", \"none\");\n        });\n\n      menu_object.style(\"position\", \"absolute\")\n        .style(\"left\", \"\" + d3.event.offsetX + \"px\")\n        .style(\"top\", \"\" + d3.event.offsetY + \"px\")\n        .style(\"display\", \"block\");\n\n    } else {\n      menu_object.style(\"display\", \"none\");\n    }\n\n    container.on(\"click\", function(d) {\n      handle_node_click(null);\n    }, true);\n\n  };\n\n  function get_initial_xy(nodes, cluster_count, exclude) {\n    var d_clusters = {\n      'id': 'root',\n      'children': []\n    };\n    for (var k = 0; k < cluster_count; k += 1) {\n      if (exclude != undefined && exclude[k + 1] != undefined) {\n        continue;\n      }\n      d_clusters.children.push({\n        'cluster_id': k + 1,\n        'children': nodes.filter(function(v) {\n          return v.cluster == k + 1;\n        })\n      });\n    }\n\n    var treemap = d3.layout.pack()\n      .size([self.width, self.height])\n      //.sticky(true)\n      .children(function(d) {\n        return d.children;\n      })\n      .value(function(d) {\n        return 1;\n      });\n\n    return treemap.nodes(d_clusters);\n  }\n\n  function prepare_data_to_graph() {\n\n    var graphMe = {};\n    graphMe.all = [];\n    graphMe.edges = [];\n    graphMe.nodes = [];\n    graphMe.clusters = [];\n\n    expandedClusters = [];\n    drawnNodes = [];\n\n\n    self.clusters.forEach(function(x) {\n      // Check if hxb2_linked is in a child\n      var hxb2_exists = x.children.some(function(c) {\n        return c.hxb2_linked\n      }) && self.hide_hxb2;\n      if (!hxb2_exists) {\n        if (x.collapsed) {\n          graphMe.clusters.push(x);\n          graphMe.all.push(x);\n        } else {\n          expandedClusters[x.cluster_id] = true;\n        }\n      }\n    });\n\n    self.nodes.forEach(function(x, i) {\n      if (expandedClusters[x.cluster]) {\n        drawnNodes[i] = graphMe.nodes.length + graphMe.clusters.length;\n        graphMe.nodes.push(x);\n        graphMe.all.push(x);\n      }\n\n    });\n\n    self.edges.forEach(function(x) {\n\n      if (!(x.removed && self.filter_edges)) {\n        if (drawnNodes[x.source] != undefined && drawnNodes[x.target] != undefined) {\n\n          var y = {};\n          for (var prop in x) {\n            y[prop] = x[prop];\n          }\n\n          y.source = drawnNodes[x.source];\n          y.target = drawnNodes[x.target];\n          graphMe.edges.push(y);\n        }\n      }\n    });\n\n    return graphMe;\n\n  }\n\n  function default_layout(clusters, nodes, exclude_cluster_ids) {\n    init_layout = get_initial_xy(nodes, self.cluster_sizes.length, exclude_cluster_ids);\n    clusters = init_layout.filter(function(v, i, obj) {\n      return !(typeof v.cluster_id === \"undefined\");\n    });\n\n    var sizes = network_layout.size();\n\n    _.each(nodes, function(n) {\n      n.x += n.dx / 2;\n      n.y += n.dy / 2\n    });\n    clusters.forEach(collapse_cluster);\n    return [clusters, nodes];\n  }\n\n  function change_spacing(delta) {\n    self.charge_correction = self.charge_correction * delta;\n    network_layout.start();\n  }\n\n  function change_window_size(delta, trigger) {\n\n    if (delta) {\n\n      var x_scale = (self.width + delta / 2) / self.width;\n      var y_scale = (self.height + delta / 2) / self.height;\n\n      self.width += delta;\n      self.height += delta;\n\n      var rescale_x = d3.scale.linear().domain(d3.extent(network_layout.nodes(), function(node) {\n        return node.x\n      }));\n      rescale_x.range(_.map(rescale_x.domain(), function(v) {\n        return v * x_scale;\n      }));\n      //.range ([50,self.width-50]),\n      var rescale_y = d3.scale.linear().domain(d3.extent(network_layout.nodes(), function(node) {\n        return node.y\n      }));\n      rescale_y.range(_.map(rescale_y.domain(), function(v) {\n        return v * y_scale;\n      }));\n\n      _.each(network_layout.nodes(), function(node) {\n        node.x = rescale_x(node.x);\n        node.y = rescale_y(node.y);\n      });\n\n    }\n\n    self.width = Math.min(Math.max(self.width, 200), 4000);\n    self.height = Math.min(Math.max(self.height, 200), 4000);\n\n    network_layout.size([self.width, self.height]);\n    network_svg.attr(\"width\", self.width).attr(\"height\", self.height);\n\n    if (trigger) {\n      network_layout.start();\n    } else {\n      if (delta) {\n        self.update(true);\n      }\n    }\n  }\n\n  self.compute_adjacency_list = _.once(function() {\n\n    self.nodes.forEach(function(n) {\n      n.neighbors = d3.set();\n    });\n\n    self.edges.forEach(function(e) {\n      self.nodes[e.source].neighbors.add(e.target);\n      self.nodes[e.target].neighbors.add(e.source);\n    });\n\n  });\n\n  self.compute_local_clustering_coefficients = _.once(function() {\n\n    self.compute_adjacency_list();\n\n    self.nodes.forEach(function(n) {\n      _.defer(function(a_node) {\n        neighborhood_size = a_node.neighbors.size();\n        if (neighborhood_size < 2) {\n          a_node.lcc = datamonkey.hivtrace.undefined;\n        } else {\n          if (neighborhood_size > 500) {\n            a_node.lcc = datamonkey.hivtrace.too_large;\n          } else {\n            // count triangles\n            neighborhood = a_node.neighbors.values();\n            counter = 0;\n            for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\n              for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\n                if (self.nodes[neighborhood[n1]].neighbors.has(neighborhood[n2])) {\n                  counter++;\n                }\n              }\n            }\n\n            a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\n          }\n        }\n\n      }, n);\n    });\n\n  });\n\n  self.get_node_by_id = function(id) {\n    return self.nodes.filter(function(n) {\n      return n.id == id;\n    })[0];\n\n\n  }\n\n  self.compute_local_clustering_coefficients_worker = _.once(function() {\n\n    var worker = new Worker('workers/lcc.js');\n\n    worker.onmessage = function(event) {\n\n      var nodes = event.data.Nodes;\n\n      nodes.forEach(function(n) {\n        node_to_update = self.get_node_by_id(n.id);\n        node_to_update.lcc = n.lcc ? n.lcc : datamonkey.hivtrace.undefined;\n      });\n\n    };\n\n    var worker_obj = {}\n    worker_obj[\"Nodes\"] = self.nodes;\n    worker_obj[\"Edges\"] = self.edges;\n    worker.postMessage(worker_obj);\n\n  });\n\n\n\n  estimate_cubic_compute_cost = _.memoize(function(c) {\n    self.compute_adjacency_list();\n    return _.reduce(_.first(_.pluck(c.children, \"degree\").sort(d3.descending), 3), function(memo, value) {\n      return memo * value;\n    }, 1);\n  }, function(c) {\n    return c.cluster_id;\n  });\n\n  self.compute_global_clustering_coefficients = _.once(function() {\n    self.compute_adjacency_list();\n\n    self.clusters.forEach(function(c) {\n      _.defer(function(a_cluster) {\n        cluster_size = a_cluster.children.length;\n        if (cluster_size < 3) {\n          a_cluster.cc = datamonkey.hivtrace.undefined;\n        } else {\n          if (estimate_cubic_compute_cost(a_cluster, true) >= 5000000) {\n            a_cluster.cc = datamonkey.hivtrace.too_large;\n          } else {\n            // pull out all the nodes that have this cluster id\n            member_nodes = [];\n\n            var triads = 0;\n            var triangles = 0;\n\n            self.nodes.forEach(function(n, i) {\n              if (n.cluster == a_cluster.cluster_id) {\n                member_nodes.push(i);\n              }\n            });\n            member_nodes.forEach(function(node) {\n              my_neighbors = self.nodes[node].neighbors.values().map(function(d) {\n                return +d;\n              }).sort(d3.ascending);\n              for (n1 = 0; n1 < my_neighbors.length; n1 += 1) {\n                for (n2 = n1 + 1; n2 < my_neighbors.length; n2 += 1) {\n                  triads += 1;\n                  if (self.nodes[my_neighbors[n1]].neighbors.has(my_neighbors[n2])) {\n                    triangles += 1;\n                  }\n                }\n              }\n            });\n\n            a_cluster.cc = triangles / triads;\n          }\n        }\n\n      }, c);\n    });\n  });\n\n  self.mark_nodes_as_processing = function(property) {\n    self.nodes.forEach(function(n) {\n      n[property] = datamonkey.hivtrace.processing\n    });\n  }\n\n  self.compute_graph_stats = function() {\n\n    d3.select(this).classed(\"disabled\", true).select(\"i\").classed({\n      \"fa-calculator\": false,\n      \"fa-cog\": true,\n      \"fa-spin\": true\n    });\n    self.mark_nodes_as_processing('lcc');\n    self.compute_local_clustering_coefficients_worker();\n    self.compute_global_clustering_coefficients();\n    d3.select(this).remove();\n\n  };\n\n\n  /*------------ Constructor ---------------*/\n  function initial_json_load() {\n    var connected_links = [];\n    var total = 0;\n    var exclude_cluster_ids = {};\n    self.has_hxb2_links = false;\n    self.cluster_sizes = [];\n\n    graph_data.Nodes.forEach(function(d) {\n      if (typeof self.cluster_sizes[d.cluster - 1] === \"undefined\") {\n        self.cluster_sizes[d.cluster - 1] = 1;\n      } else {\n        self.cluster_sizes[d.cluster - 1]++;\n      }\n      if (\"is_lanl\" in d) {\n        d.is_lanl = d.is_lanl == \"true\";\n      }\n\n\n      if (d.attributes.indexOf(\"problematic\") >= 0) {\n        self.has_hxb2_links = d.hxb2_linked = true;\n      }\n\n    });\n\n    /* add buttons and handlers */\n    /* clusters first */\n\n    if (button_bar_ui) {\n\n      $('#' + button_bar_ui + '_cluster_zoom').on('show.bs.modal', function(event) {\n        var link_clicked = $(event.relatedTarget);\n        var cluster_id = link_clicked.data(\"cluster\");\n        var modal = d3.select('#' + button_bar_ui + '_cluster_zoom');\n        modal.selectAll(\".modal-title\").text(\"Cluster \" + cluster_id);\n\n        $(\"#\" + button_bar_ui + \"_cluster_zoom_svg_export\").on(\"click\", function(e) {\n          datamonkey.save_image(\"png\", \"#\" + button_bar_ui + \"_cluster_zoom_svg\");\n        });\n\n        var node_indices = {};\n        var used_index = 0;\n\n        var only_this_cluster = {\n          \"Nodes\": _.map(_.filter(self.nodes, function(n, i) {\n            if (n.cluster == cluster_id) {\n              node_indices[i] = used_index++;\n              return true;\n            }\n            return false;\n          }), function(n) {\n            var nn = _.clone(n);\n            nn.cluster = 1;\n            delete nn[\"parent\"];\n            return nn;\n          }),\n          \"Edges\": _.map(_.filter(self.edges, function(e) {\n            if (e.source in node_indices && e.target in node_indices) {\n              return true;\n            }\n            return false;\n          }), function(e) {\n            var ne = _.clone(e);\n            ne.target = node_indices[ne.target];\n            ne.source = node_indices[ne.source];\n            return ne;\n          }),\n\n        };\n\n        only_this_cluster[_networkGraphAttrbuteID] = self.json[_networkGraphAttrbuteID];\n\n        hivtrace_cluster_network_graph(only_this_cluster, \"#\" + button_bar_ui + \"_cluster_zoom_svg\", null, null, null, null, null, null, null, \"#\" + button_bar_ui + \"_cluster_zoom_body\", {\n          \"expand\": [1],\n          \"charge\": 10,\n          \"colorizer\": self.colorizer,\n          \"node_shaper\": self.node_shaper,\n          \"width\": 600\n        });\n\n      });\n\n      $('#' + button_bar_ui + '_cluster_list').on('show.bs.modal', function(event) {\n\n        var link_clicked = $(event.relatedTarget);\n        var cluster_id = link_clicked.data(\"cluster\");\n        var modal = d3.select('#' + button_bar_ui + '_cluster_list');\n        modal.selectAll(\".modal-title\").text(\"Listing nodes in cluster \" + cluster_id);\n\n        var the_list = modal.select('#' + button_bar_ui + '_cluster_list_payload');\n        the_list.selectAll('*').remove();\n\n        var allowed_types = {\n          \"String\": 1,\n          \"Date\": 1,\n          \"Number\": 1\n        };\n\n        var column_ids = _.filter(self.json[_networkGraphAttrbuteID], function(d) {\n          return d.type in allowed_types;\n        });\n\n        _.each(_.filter(self.nodes, function(n) {\n          return n.cluster == cluster_id;\n        }), function(node) {\n          var patient_record = the_list.append(\"li\");\n          patient_record.append(\"code\").text(node.id);\n          var patient_list = patient_record.append(\"dl\").classed(\"dl-horizontal\", true);\n          _.each(column_ids, function(column) {\n            patient_list.append(\"dt\").text(column.raw_attribute_key);\n            patient_list.append(\"dd\").text(attribute_node_value_by_id(node, column.raw_attribute_key));\n\n          });\n        });\n\n\n      });\n\n      var cluster_ui_container = d3.select(\"#\" + button_bar_ui + \"_cluster_operations_container\");\n\n      var cluster_commands = [\n        [\"Expand All\", function() {\n          return self.expand_some_clusters()\n        }, true, 'hivtrace-expand-all'],\n        [\"Collapse All\", function() {\n          return self.collapse_some_clusters()\n        }, true, 'hivtrace-collapse-all'],\n        [\"Expand Filtered\", function() {\n          return self.expand_some_clusters(self.select_some_clusters(function(n) {\n            return n.match_filter;\n          }))\n        }, true, 'hivtrace-expand-filtered'],\n        [\"Collapse Filtered\", function() {\n          return self.collapse_some_clusters(self.select_some_clusters(function(n) {\n            return n.match_filter;\n          }))\n        }, true, 'hivtrace-collapse-filtered'],\n        [\"Hide problematic clusters\", function(item) {\n          d3.select(item).text(self.hide_hxb2 ? \"Hide problematic clusters\" : \"Show problematic clusters\");\n          self.toggle_hxb2();\n        }, self.has_hxb2_links, 'hivtrace-hide-problematic-clusters']\n      ];\n\n      if (!_is_CDC_) {\n        cluster_commands.push([\"Show removed edges\", function(item) {\n          self.filter_edges = !self.filter_edges;\n          d3.select(item).text(self.filter_edges ? \"Show removed edges\" : \"Hide removed edges\");\n          self.update(false);\n        }, function() {\n          return _.some(self.edges, function(d) {\n            return d.removed;\n          });\n        }, 'hivtrace-show-removed-edges'])\n\n      }\n\n\n      cluster_commands.forEach(function(item, index) {\n        var handler_callback = item[1];\n        if (item[2]) {\n          this.append(\"li\").append(\"a\")\n            .text(item[0])\n            .attr(\"href\", \"#\")\n            .attr(\"id\", item[3])\n            .on(\"click\", function(e) {\n              handler_callback(this);\n              d3.event.preventDefault();\n            });\n        }\n      }, cluster_ui_container);\n\n\n      var button_group = d3.select(\"#\" + button_bar_ui + \"_button_group\");\n\n      if (!button_group.empty()) {\n        button_group.append(\"button\").classed(\"btn btn-default btn-sm\", true).attr(\"title\", \"Expand spacing\").on(\"click\", function(d) {\n          change_spacing(5 / 4);\n        }).append(\"i\").classed(\"fa fa-plus\", true);\n        button_group.append(\"button\").classed(\"btn btn-default btn-sm\", true).attr(\"title\", \"Compress spacing\").on(\"click\", function(d) {\n          change_spacing(4 / 5);\n        }).append(\"i\").classed(\"fa fa-minus\", true);\n        button_group.append(\"button\").classed(\"btn btn-default btn-sm\", true).attr(\"title\", \"Enlarge window\").on(\"click\", function(d) {\n          change_window_size(100, true);\n        }).append(\"i\").classed(\"fa fa-expand\", true);\n        button_group.append(\"button\").classed(\"btn btn-default btn-sm\", true).attr(\"title\", \"Shrink window\").on(\"click\", function(d) {\n          change_window_size(-100, true);\n        }).append(\"i\").classed(\"fa fa-compress\", true);\n\n\n        if (!_is_CDC_) {\n          button_group.append(\"button\")\n            .classed(\"btn btn-default btn-sm\", true)\n            .attr(\"title\", \"Compute graph statistics\")\n            .attr(\"id\", \"hivtrace-compute-graph-statistics\")\n            .on(\"click\", function(d) {\n              _.bind(self.compute_graph_stats, this)();\n            })\n            .append(\"i\")\n            .classed(\"fa fa-calculator\", true);\n        }\n\n        button_group.append(\"button\")\n          .classed(\"btn btn-default btn-sm\", true)\n          .attr(\"title\", \"Save Image\")\n          .attr(\"id\", \"hivtrace-export-image\")\n          .on(\"click\", function(d) {\n            datamonkey.save_image(\"png\", \"#network-svg\");\n          })\n          .append(\"i\").classed(\"fa fa-image\", true);\n      }\n\n      $(\"#\" + button_bar_ui + \"_filter\").on(\"input propertychange\", _.throttle(function(e) {\n        var filter_value = $(this).val();\n        self.filter(filter_value.split(\" \").filter(function(d) {\n          return d.length > 0;\n        }).map(function(d) {\n          return new RegExp(d, \"i\")\n        }));\n      }, 250));\n\n    }\n\n\n    if (_networkGraphAttrbuteID in json) {\n      attributes = json[_networkGraphAttrbuteID];\n    } else {\n      if (attributes && \"hivtrace\" in attributes) {\n        attributes = attributes[\"hivtrace\"];\n      }\n    }\n\n    if (attributes) {\n      /*\n         map attributes into nodes and into the graph object itself using\n         _networkGraphAttrbuteID as the key\n      */\n      if (\"attribute_map\" in attributes) {\n        var attribute_map = attributes[\"attribute_map\"];\n\n        if (\"map\" in attribute_map && attribute_map[\"map\"].length > 0) {\n          graph_data[_networkGraphAttrbuteID] = attribute_map[\"map\"].map(function(a, i) {\n            return {\n              'label': a,\n              'type': null,\n              'values': {},\n              'index': i,\n              'range': 0\n            };\n          });\n\n          graph_data.Nodes.forEach(function(n) {\n            n[_networkGraphAttrbuteID] = n.id.split(attribute_map[\"delimiter\"]);\n            n[_networkGraphAttrbuteID].forEach(function(v, i) {\n              if (i < graph_data[_networkGraphAttrbuteID].length) {\n                if (!(v in graph_data[_networkGraphAttrbuteID][i][\"values\"])) {\n                  graph_data[_networkGraphAttrbuteID][i][\"values\"][v] = graph_data[_networkGraphAttrbuteID][i][\"range\"];\n                  graph_data[_networkGraphAttrbuteID][i][\"range\"] += 1;\n                }\n              }\n              //graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = 1 + (graph_data [_networkGraphAttrbuteID][i][\"values\"][v] ? graph_data [_networkGraphAttrbuteID][i][\"values\"][v] : 0);\n            });\n          });\n\n          graph_data[_networkGraphAttrbuteID].forEach(function(d) {\n            if (d['range'] < graph_data.Nodes.length && d['range'] > 1 && d['range'] <= 20) {\n              d['type'] = 'category';\n            }\n          });\n        }\n      }\n\n\n      _.each(_networkPredefinedAttributeTransforms, function(computed, key) {\n        if (!computed['depends'] || _.has(graph_data[_networkGraphAttrbuteID], computed['depends'])) {\n          var extension = {};\n          extension[key] = computed;\n          _.extend(graph_data[_networkGraphAttrbuteID], extension);\n          _.each(graph_data.Nodes, function(node) {\n            inject_attribute_node_value_by_id(node, key, computed['map'](node));\n          });\n        }\n      });\n\n      // populate the UI elements\n      if (button_bar_ui) {\n        // decide if the variable can be considered categorical by examining its range\n        var valid_cats = _.filter(_.map(graph_data[_networkGraphAttrbuteID], function(d, k) {\n          d['raw_attribute_key'] = k;\n          if (d['type'] == \"String\") {\n            d['value_range'] = _.keys(_.countBy(graph_data.Nodes, function(nd) {\n              return attribute_node_value_by_id(nd, k);\n            }));\n            d['dimension'] = d[\"value_range\"].length;\n          } else {\n            if ('enum' in d) {\n              d[\"value_range\"] = _.clone(d[\"enum\"]);\n              d[\"value_range\"].push(_networkMissing);\n              d['dimension'] = d[\"value_range\"].length;\n              d['no-sort'] = true;\n            }\n          }\n          return d;\n        }), function(d) {\n          return 'value_range' in d && d['value_range'].length <= 15;\n        });\n\n        var valid_shapes = _.filter(valid_cats, function(d) {\n          return d.dimension <= 5;\n        });\n\n\n        // sort values alphabetically for consistent coloring\n\n        _.each([valid_cats, valid_shapes], function(list) {\n          _.each(list, function(d) {\n            var values;\n            if (d['no-sort']) {\n              values = d['value_range'];\n            } else {\n              values = d['value_range'].sort();\n            }\n\n\n\n\n            var map = new Object;\n\n            _.each(values, function(d2, i) {\n              map[d2] = i;\n            });\n\n            d['value_map'] = function(v, key) {\n              return key ? (key == 'lookup' ? _.invert(map) : map) : map[v];\n            };\n\n          })\n        });\n\n\n        var valid_scales = _.filter(_.map(graph_data[_networkGraphAttrbuteID], function(d, k) {\n          d['raw_attribute_key'] = k;\n          if (d.type == \"Number\") {\n            var values = _.filter(_.map(graph_data.Nodes, function(nd) {\n              return attribute_node_value_by_id(nd, k);\n            }), function(v) {\n              return v == _networkMissing ? null : v;\n            });\n            // automatically determine the scale and see what spaces the values most evenly\n            d['value_range'] = d3.extent(values);\n\n            var low_var = Infinity;\n\n\n            _.each([d3.scale.linear(), d3.scale.log(), d3.scale.pow().exponent(1 / 3), d3.scale.pow().exponent(0.25), d3.scale.pow().exponent(0.5), d3.scale.pow().exponent(1 / 8), d3.scale.pow().exponent(1 / 16)], function(scl) {\n              var bins = _.map(_.range(_networkContinuousColorStops), function() {\n                return 0.\n              });\n              scl.range([0, _networkContinuousColorStops - 1]).domain(d['value_range']);\n              _.each(values, function(v) {\n                bins[Math.floor(scl(v))]++;\n              });\n\n              var mean = values.length / _networkContinuousColorStops;\n              var vrnc = _.reduce(bins, function(p, c) {\n                return p + (c - mean) * (c - mean);\n              });\n\n              if (vrnc < low_var) {\n                low_var = vrnc;\n                d['scale'] = scl;\n              }\n\n            });\n          }\n          return d;\n        }), function(d) {\n          return d.type == \"Number\";\n        });\n\n\n\n\n        //valid_cats.splice (0,0, {'label' : 'None', 'index' : -1});\n\n        [d3.select(\"#\" + button_bar_ui + \"_attributes\"), d3.select(\"#\" + button_bar_ui + \"_attributes_cat\")].forEach(function(m) {\n\n          m.selectAll(\"li\").remove();\n\n          var menu_items = [\n            [\n              ['None', null, _.partial(handle_attribute_categorical, null)]\n            ],\n            [\n              ['Categorical', 'heading', null]\n            ]\n          ].concat(valid_cats.map(function(d, i) {\n            return [\n              [d['label'], d['raw_attribute_key'], _.partial(handle_attribute_categorical, d['raw_attribute_key'])]\n            ];\n          }));\n\n\n          if (valid_scales.length) {\n            menu_items = menu_items.concat([\n              [\n                ['Continuous', 'heading', null]\n              ]\n            ]).concat(valid_scales.map(function(d, i) {\n              return [\n                [d['label'], d['raw_attribute_key'],\n                  _.partial(handle_attribute_continuous, d['raw_attribute_key'])\n                ]\n              ];\n            }));\n          }\n\n          var cat_menu = m.selectAll(\"li\")\n            .data(menu_items);\n\n\n          cat_menu.enter().append(\"li\").classed(\"disabled\", function(d) {\n            return d[0][1] == 'heading';\n          }).style(\"font-variant\", function(d) {\n            return d[0][1] < -1 ? \"small-caps\" : \"normal\";\n          });\n\n          cat_menu.selectAll(\"a\").data(function(d) {\n              return d;\n            })\n            .enter()\n            .append(\"a\")\n            .text(function(d, i, j) {\n              return d[0];\n            })\n            .attr(\"style\", function(d, i, j) {\n              if (d[1] == 'heading') return 'font-style: italic';\n              if (j == 0) {\n                return ' font-weight: bold;'\n              };\n              return null;\n            })\n            .attr('href', '#')\n            .on(\"click\", function(d) {\n              if (d[2]) {\n                d[2].call()\n              }\n            });\n        });\n\n        [d3.select(\"#\" + button_bar_ui + \"_shapes\")].forEach(function(m) {\n\n          m.selectAll(\"li\").remove();\n          var cat_menu = m.selectAll(\"li\")\n            .data([\n              [\n                ['None', null, _.partial(handle_shape_categorical, null)]\n              ]\n            ].concat(valid_shapes.map(function(d, i) {\n              return [\n                [d['label'], d['raw_attribute_key'], _.partial(handle_shape_categorical, d['raw_attribute_key'])]\n              ];\n            })));\n\n          cat_menu.enter().append(\"li\").style(\"font-variant\", function(d) {\n            return d[0][1] < -1 ? \"small-caps\" : \"normal\";\n          });\n\n          cat_menu.selectAll(\"a\").data(function(d) {\n              return d;\n            })\n            .enter()\n            .append(\"a\")\n            .text(function(d, i, j) {\n              return d[0];\n            })\n            .attr(\"style\", function(d, i, j) {\n              if (j == 0) {\n                return ' font-weight: bold;'\n              };\n              return null;\n            })\n            .attr('href', '#')\n            .on(\"click\", function(d) {\n              if (d[2]) {\n                d[2].call()\n              }\n            });\n        });\n\n        $(\"#\" + button_bar_ui + \"_opacity_invert\").on(\"click\", function(e) {\n          if (self.colorizer['opacity_scale']) {\n            self.colorizer['opacity_scale'].range(self.colorizer['opacity_scale'].range().reverse());\n            self.update(true);\n            draw_attribute_labels();\n\n          }\n          $(this).toggleClass(\"btn-active btn-default\");\n\n        });\n\n        $(\"#\" + button_bar_ui + \"_attributes_invert\").on(\"click\", function(e) {\n          if (self.colorizer['category_id']) {\n            graph_data[_networkGraphAttrbuteID][self.colorizer['category_id']]['scale'].range(graph_data[_networkGraphAttrbuteID][self.colorizer['category_id']]['scale'].range().reverse());\n            self.clusters.forEach(function(the_cluster) {\n              the_cluster[\"gradient\"] = compute_cluster_gradient(the_cluster, self.colorizer['category_id']);\n            });\n            self.update(true);\n            draw_attribute_labels();\n\n          }\n          $(this).toggleClass(\"btn-active btn-default\");\n\n        });\n\n        [d3.select(\"#\" + button_bar_ui + \"_opacity\")].forEach(function(m) {\n\n          m.selectAll(\"li\").remove();\n          var cat_menu = m.selectAll(\"li\")\n            .data([\n              [\n                ['None', null, _.partial(handle_attribute_opacity, null)]\n              ]\n            ].concat(valid_scales.map(function(d, i) {\n              return [\n                [d['label'], d['raw_attribute_key'], _.partial(handle_attribute_opacity, d['raw_attribute_key'])]\n              ];\n            })));\n\n\n          cat_menu.enter().append(\"li\").style(\"font-variant\", function(d) {\n            return d[0][1] < -1 ? \"small-caps\" : \"normal\";\n          });\n          cat_menu.selectAll(\"a\").data(function(d) {\n              return d;\n            })\n            .enter()\n            .append(\"a\")\n            .text(function(d, i, j) {\n              return d[0];\n            })\n            .attr(\"style\", function(d, i, j) {\n              if (j == 0) {\n                return ' font-weight: bold;'\n              };\n              return null;\n            })\n            .attr('href', '#')\n            .on(\"click\", function(d) {\n              if (d[2]) {\n                d[2].call()\n              }\n            });\n        });\n\n      }\n    }\n\n    if (self.cluster_sizes.length > max_points_to_render) {\n      var sorted_array = self.cluster_sizes.map(function(d, i) {\n        return [d, i + 1];\n      }).sort(function(a, b) {\n        return a[0] - b[0];\n      });\n\n      for (var k = 0; k < sorted_array.length - max_points_to_render; k++) {\n        exclude_cluster_ids[sorted_array[k][1]] = 1;\n      }\n      warning_string = \"Excluded \" + (sorted_array.length -\n          max_points_to_render) + \" clusters (maximum size \" +\n        sorted_array[k - 1][0] + \" nodes) because only \" +\n        max_points_to_render + \" points can be shown at once.\";\n    }\n\n    // Initialize class attributes\n    singletons = graph_data.Nodes.filter(function(v, i) {\n      return v.cluster === null;\n    }).length;\n    self.nodes = graph_data.Nodes.filter(function(v, i) {\n      if (v.cluster && typeof exclude_cluster_ids[v.cluster] === \"undefined\") {\n        connected_links[i] = total++;\n        return true;\n      }\n      return false;\n    });\n    self.edges = graph_data.Edges.filter(function(v, i) {\n      return connected_links[v.source] != undefined && connected_links[v.target] != undefined\n    });\n    self.edges = self.edges.map(function(v, i) {\n      v.source = connected_links[v.source];\n      v.target = connected_links[v.target];\n      v.id = i;\n      return v;\n    });\n\n    compute_node_degrees(self.nodes, self.edges);\n\n    var r = default_layout(self.clusters, self.nodes, exclude_cluster_ids);\n    self.clusters = r[0];\n    self.nodes = r[1];\n    self.clusters.forEach(function(d, i) {\n      cluster_mapping[d.cluster_id] = i;\n      d.hxb2_linked = d.children.some(function(c) {\n        return c.hxb2_linked\n      });\n      var degrees = d.children.map(function(c) {\n        return c.degree;\n      });\n      degrees.sort(d3.ascending);\n      d.degrees = datamonkey_describe_vector(degrees);\n      d.distances = [];\n    });\n\n\n    self.edges.forEach(function(e, i) {\n      self.clusters[cluster_mapping[self.nodes[e.target].cluster]].distances.push(e.length);\n    });\n\n    self.clusters.forEach(function(d, i) {\n      d.distances = datamonkey_describe_vector(d.distances);\n    });\n    //self.clusters\n\n\n    self.update();\n\n  }\n\n  function sort_table_toggle_icon(element, value) {\n    if (value) {\n      $(element).data(\"sorted\", value);\n      d3.select(element).selectAll(\"i\").classed(\"fa-sort-amount-desc\", value == \"desc\").classed(\"fa-sort-amount-asc\", value == \"asc\").classed(\"fa-sort\", value == \"unsorted\");\n    } else {\n      var sorted_state = $(element).data(\"sorted\");\n      sort_table_toggle_icon(element, sorted_state == \"asc\" ? \"desc\" : \"asc\");\n      return sorted_state == \"asc\" ? d3.descending : d3.ascending;\n    }\n  }\n\n  function sort_table_by_column(element, datum) {\n    d3.event.preventDefault();\n    var table_element = $(element).closest(\"table\");\n    if (table_element.length) {\n      var sort_on = parseInt($(element).data(\"column-id\"));\n      var sort_key = $(element).data(\"sort-on\");\n      var sorted_state = ($(element).data(\"sorted\"));\n      var sorted_function = sort_table_toggle_icon(element);\n\n      sort_accessor = sort_key ? function(x) {\n        var val = x[sort_key];\n        if (typeof(val) === \"function\") return val();\n        return val;\n      } : function(x) {\n        return x;\n      };\n\n      d3.select(table_element[0]).select(\"tbody\").selectAll(\"tr\").sort(function(a, b) {\n        return sorted_function(sort_accessor(a[sort_on]), sort_accessor(b[sort_on]));\n      });\n\n      // select all other elements from thead and toggle their icons\n\n      $(table_element).find(\"thead [data-column-id]\")\n        .filter(function() {\n          return parseInt($(this).data(\"column-id\")) != sort_on;\n        })\n        .each(function() {\n          sort_table_toggle_icon(this, \"unsorted\");\n        });\n    }\n  }\n\n  function format_a_cell(data, index, item) {\n\n    var this_sel = d3.select(item);\n\n    current_value = typeof(data.value) === \"function\" ? data.value() : data.value;\n\n    if (\"callback\" in data) {\n      data.callback(item, current_value);\n    } else {\n      var repr = \"format\" in data ? data.format(current_value) : current_value;\n      if (\"html\" in data) this_sel.html(repr);\n      else this_sel.text(repr);\n      if (\"sort\" in data) {\n        var clicker = this_sel.append(\"a\").property(\"href\", \"#\").on(\"click\", function(d) {\n          sort_table_by_column(this, d);\n        }).attr(\"data-sorted\", \"unsorted\").attr(\"data-column-id\", index).attr(\"data-sort-on\", data.sort);\n        clicker.append(\"i\").classed(\"fa fa-sort\", true).style(\"margin-left\", \"0.2em\");\n      }\n    }\n    if (\"help\" in data) {\n      this_sel.attr(\"title\", data.help);\n    }\n\n  }\n\n  function add_a_sortable_table(container, headers, content) {\n\n    var thead = container.selectAll(\"thead\");\n    if (thead.empty()) {\n      thead = container.append(\"thead\");\n      thead.selectAll(\"tr\").data(headers).enter().append(\"tr\").selectAll(\"th\").data(function(d) {\n        return d;\n      }).enter().append(\"th\").\n      call(function(selection) {\n        return selection.each(function(d, i) {\n          format_a_cell(d, i, this);\n        })\n      });\n    }\n\n    var tbody = container.selectAll(\"tbody\");\n    if (tbody.empty()) {\n      tbody = container.append(\"tbody\");\n      tbody.selectAll(\"tr\").data(content).enter().append(\"tr\").selectAll(\"td\").data(function(d) {\n        return d;\n      }).enter().append(\"td\").call(function(selection) {\n        return selection.each(function(d, i) {\n          handle_cluster_click\n          format_a_cell(d, i, this);\n        })\n      });\n    }\n\n\n  }\n\n  function _cluster_table_draw_id(element, payload) {\n    var this_cell = d3.select(element);\n    this_cell.selectAll(\"*\").remove();\n    this_cell.append(\"span\").text(payload).style(\"padding-right\", \"0.5em\");\n    this_cell.append(\"button\").classed(\"btn btn-primary btn-xs pull-right\", true).text(\"Zoom\").attr(\"data-toggle\", \"modal\").attr(\"data-target\", \"#\" + button_bar_ui + \"_cluster_zoom\").attr(\"data-cluster\", payload);\n    this_cell.append(\"button\").classed(\"btn btn-xs pull-right\", true).text(\"List\").attr(\"data-toggle\", \"modal\").attr(\"data-target\", \"#\" + button_bar_ui + \"_cluster_list\").attr(\"data-cluster\", payload);\n  }\n\n  function _cluster_table_draw_buttons(element, payload) {\n\n    var this_cell = d3.select(element);\n    var labels = [\n      [payload[0] ? \"expand\" : \"collapse\", 0]\n    ];\n    if (payload[1]) {\n      labels.push([\"problematic\", 1]);\n    }\n    if (payload[2]) {\n      labels.push([\"match\", 1]);\n    }\n    var buttons = this_cell.selectAll(\"button\").data(labels);\n    buttons.enter().append(\"button\");\n    buttons.exit().remove();\n    buttons.classed(\"btn btn-primary btn-xs\", true).text(function(d) {\n        return d[0];\n      })\n      .attr(\"disabled\", function(d) {\n        return d[1] ? \"disabled\" : null\n      })\n      .on(\"click\", function(d) {\n        if (d[1] == 0) {\n          if (payload[0]) {\n            expand_cluster(self.clusters[payload[payload.length - 1] - 1], true);\n          } else {\n            collapse_cluster(self.clusters[payload[payload.length - 1] - 1]);\n          }\n          format_a_cell(d3.select(element).datum(), null, element);\n        }\n      });\n\n  };\n\n  function _node_table_draw_buttons(element, payload) {\n    var this_cell = d3.select(element);\n    var labels = [\n      [payload[0] ? \"hide\" : \"show\", 0]\n    ];\n\n    var buttons = this_cell.selectAll(\"button\").data(labels);\n    buttons.enter().append(\"button\");\n    buttons.exit().remove();\n    buttons.classed(\"btn btn-primary btn-xs btn-node-property\", true).text(function(d) {\n        return d[0];\n      })\n      .attr(\"disabled\", function(d) {\n        return d[1] ? \"disabled\" : null\n      })\n      .on(\"click\", function(d) {\n        if (d[1] == 0) {\n          if (payload[0]) {\n            collapse_cluster(self.clusters[payload[payload.length - 1] - 1], true);\n          } else {\n            expand_cluster(self.clusters[payload[payload.length - 1] - 1]);\n          }\n          format_a_cell(d3.select(element).datum(), null, element);\n        }\n      });\n\n  };\n\n  self.update_volatile_elements = function(container) {\n    container.selectAll(\"td\").filter(function(d, i) {\n      return (\"volatile\" in d);\n    }).each(function(d, i) {\n      format_a_cell(d, i, this);\n    });\n  };\n\n  function draw_node_table() {\n\n    if (self.node_table) {\n      add_a_sortable_table(self.node_table,\n        // headers\n        [\n          [{\n              value: \"ID\",\n              sort: \"value\",\n              help: \"Node ID\"\n            },\n            {\n              value: \"Status\",\n              sort: \"value\"\n            },\n            {\n              value: \"# of links\",\n              sort: \"value\",\n              help: \"Number of links (Node degree)\"\n            },\n            {\n              value: \"Cluster\",\n              sort: \"value\",\n              help: \"Which cluster does the node belong to\"\n            }\n          ]\n        ],\n        // rows\n        self.nodes.map(function(n, i) {\n          return [{\n              \"value\": n.id,\n              help: \"Node ID\"\n            },\n            {\n              \"value\": function() {\n                return [!self.clusters[n.cluster - 1].collapsed, n.cluster]\n              },\n              \"callback\": _node_table_draw_buttons,\n              \"volatile\": true\n            },\n            {\n              \"value\": n.degree,\n              help: \"Node degree\"\n            },\n            {\n              \"value\": n.cluster,\n              help: \"Which cluster does the node belong to\"\n            }\n          ];\n\n        }));\n    }\n  }\n\n  function draw_cluster_table() {\n    if (self.cluster_table) {\n      add_a_sortable_table(self.cluster_table,\n        // headers\n        [\n          [{\n              value: \"Cluster ID\",\n              sort: \"value\",\n              help: \"Unique cluster ID\"\n            },\n            {\n              value: \"Visibility\",\n              sort: \"value\"\n            },\n            {\n              value: \"Size\",\n              sort: \"value\",\n              help: \"Number of nodes in the cluster\"\n            },\n            {\n              value: \"# links/node<br>Mean [Median, IQR]\",\n              html: true\n            },\n            {\n              value: \"Genetic distance<br>Mean [Median, IQR]\",\n              help: \"Genetic distance among nodes in the cluster\",\n              html: true\n            }\n          ]\n        ],\n        self.clusters.map(function(d, i) {\n          // rows\n          return [{\n              value: d.cluster_id,\n              callback: _cluster_table_draw_id\n            },\n            {\n              value: function() {\n                return [d.collapsed, d.hxb2_linked, d.match_filter, d.cluster_id]\n              },\n              callback: _cluster_table_draw_buttons,\n              volatile: true\n            },\n            {\n              value: d.children.length\n            },\n            {\n              value: d.degrees,\n              format: function(d) {\n                return _defaultFloatFormat(d['mean']) + \" [\" + _defaultFloatFormat(d['median']) + \", \" + _defaultFloatFormat(d['Q1']) + \" - \" + _defaultFloatFormat(d['Q3']) + \"]\"\n              }\n            },\n            {\n              value: d.distances,\n              format: function(d) {\n                return _defaultFloatFormat(d['mean']) + \" [\" + _defaultFloatFormat(d['median']) + \", \" + _defaultFloatFormat(d['Q1']) + \" - \" + _defaultFloatFormat(d['Q3']) + \"]\"\n              }\n            }\n          ];\n\n        })\n      );\n    }\n  }\n\n  /*------------ Update layout code ---------------*/\n  function update_network_string(draw_me) {\n    if (network_status_string) {\n      var clusters_shown = self.clusters.length - draw_me.clusters.length,\n        clusters_removed = self.cluster_sizes.length - self.clusters.length,\n        nodes_removed = graph_data.Nodes.length - singletons - self.nodes.length;\n\n      /*var s = \"Displaying a network on <strong>\" + self.nodes.length + \"</strong> nodes, <strong>\" + self.clusters.length + \"</strong> clusters\"\n              + (clusters_removed > 0 ? \" (an additional \" + clusters_removed + \" clusters and \" + nodes_removed + \" nodes have been removed due to network size constraints)\" : \"\") + \". <strong>\"\n              + clusters_shown +\"</strong> clusters are expanded. Of <strong>\" + self.edges.length + \"</strong> edges, <strong>\" + draw_me.edges.length + \"</strong>, and of  <strong>\" + self.nodes.length  + \" </strong> nodes,  <strong>\" + draw_me.nodes.length + \" </strong> are displayed. \";\n      if (singletons > 0) {\n          s += \"<strong>\" +singletons + \"</strong> singleton nodes are not shown. \";\n      }*/\n\n      var s = \"<span class = 'badge'>\" + self.clusters.length + \"</span> clusters <span class = 'label label-primary'>\" + clusters_shown + \" expanded</span> <span class = 'badge'> \" +\n        self.nodes.length + \"</span> nodes <span class = 'label label-primary'>\" + draw_me.nodes.length + \" shown</span> \" +\n        \"<span class = 'badge'>\" + self.edges.length + \"</span> \" + (_is_CDC_ ? \"links\" : \"edges\") + \" <span class = 'label label-primary'>\" + draw_me.edges.length + \" shown</span>\";\n\n\n      d3.select(network_status_string).html(s);\n    }\n  }\n\n  function draw_a_node(container, node) {\n    container = d3.select(container);\n\n    var symbol_type = (node.hxb2_linked && !node.is_lanl) ? \"cross\" : (node.is_lanl ? \"triangle-down\" : self.node_shaper['shaper'](node));\n\n    container.attr(\"d\", datamonkey.hivtrace.symbol(symbol_type).size(node_size(node)))\n      .attr('class', 'node')\n      .classed('selected_object', function(d) {\n        return d.match_filter\n      })\n      .attr(\"transform\", function(d) {\n        return \"translate(\" + d.x + \",\" + d.y + \")\";\n      })\n      .style('fill', function(d) {\n        return node_color(d);\n      })\n      .style('opacity', function(d) {\n        return node_opacity(d);\n      })\n      .on('click', handle_node_click)\n      .on('mouseover', node_pop_on)\n      .on('mouseout', node_pop_off)\n      .call(network_layout.drag().on('dragstart', node_pop_off));\n\n  }\n\n  function draw_a_cluster(container, the_cluster) {\n\n    container_group = d3.select(container);\n\n    var draw_from = the_cluster[\"binned_attributes\"] ? the_cluster[\"binned_attributes\"].map(function(d) {\n      return d.concat([0]);\n    }) : [\n      [null, 1, 0]\n    ];\n\n    if (the_cluster.match_filter) {\n      draw_from = draw_from.concat([\n        [\"selected\", the_cluster.match_filter, 1],\n        [\"not selected\", the_cluster.children.length - the_cluster.match_filter, 1]\n      ]);\n    }\n\n    var sums = [d3.sum(draw_from.filter(function(d) {\n        return d[2] == 0\n      }), function(d) {\n        return d[1];\n      }),\n      d3.sum(draw_from.filter(function(d) {\n        return d[2] != 0\n      }), function(d) {\n        return d[1];\n      })\n    ];\n\n    var running_totals = [0, 0];\n\n    draw_from = draw_from.map(function(d) {\n      index = d[2];\n      var v = {\n        'container': container,\n        'cluster': the_cluster,\n        'startAngle': running_totals[index] / sums[index] * 2 * Math.PI,\n        'endAngle': (running_totals[index] + d[1]) / sums[index] * 2 * Math.PI,\n        'name': d[0],\n        'rim': index > 0\n      };\n      running_totals[index] += d[1];\n      return v;\n\n    });\n\n\n    var arc_radius = cluster_box_size(the_cluster) * 0.5;\n    var paths = container_group.selectAll(\"path\").data(draw_from);\n    paths.enter().append(\"path\");\n    paths.exit().remove();\n\n    paths.classed(\"cluster\", true)\n      .classed(\"hiv-trace-problematic\", function(d) {\n        return the_cluster.hxb2_linked && !d.rim;\n      })\n      .classed(\"hiv-trace-selected\", function(d) {\n        return d.rim;\n      })\n      .attr(\"d\", function(d) {\n        return (d.rim ?\n          d3.svg.arc().innerRadius(arc_radius + 2).outerRadius(arc_radius + 5) :\n          d3.svg.arc().innerRadius(0).outerRadius(arc_radius))(d);\n      })\n      .style(\"fill\", function(d, i) {\n        return d.rim ? self.colorizer['selected'](d.name) : (the_cluster[\"gradient\"] ? 'url(#' + the_cluster[\"gradient\"] + ')' : cluster_color(the_cluster, d.name));\n      });\n\n\n\n  }\n\n  function handle_shape_categorical(cat_id) {\n    var set_attr = \"None\";\n\n    [\"#\" + button_bar_ui + \"_shapes\"].forEach(function(m) {\n      d3.select(m).selectAll(\"li\").selectAll(\"a\").attr(\"style\", function(d, i) {\n        if (d[1] == cat_id) {\n          set_attr = d[0];\n          return ' font-weight: bold;'\n        };\n        return null;\n      });\n      d3.select(m + \"_label\").html(\"Shape: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n\n    if (cat_id) {\n      var shape_mapper = d3.scale.ordinal().domain(_.range(0, graph_data[_networkGraphAttrbuteID][cat_id].dimension)).range(_networkShapeOrdering);\n      self.node_shaper['id'] = cat_id;\n      self.node_shaper['shaper'] = function(d) {\n        return shape_mapper(graph_data[_networkGraphAttrbuteID][cat_id]['value_map'](attribute_node_value_by_id(d, cat_id)));\n      };\n      self.node_shaper['category_map'] = graph_data[_networkGraphAttrbuteID][cat_id]['value_map'];\n    } else {\n      self.node_shaper.id = null;\n      self.node_shaper.shaper = function() {\n        return 'circle'\n      };\n      self.node_shaper['category_map'] = null;\n    }\n    //console.log (graph_data [_networkGraphAttrbuteID][cat_id]['value_map'], self.node_shaper.domain(), self.node_shaper.range());\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n  }\n\n  function draw_attribute_labels() {\n\n    legend_svg.selectAll(\"g.hiv-trace-legend\").remove();\n    var offset = 10;\n\n    if (self.colorizer['category_id']) {\n      legend_svg.append(\"g\").attr(\"transform\", \"translate(0,\" + offset + \")\").classed('hiv-trace-legend', true).append(\"text\").text(\"Color: \" + self.colorizer['category_id']).style(\"font-weight\", \"bold\");\n      offset += 18;\n\n      if (self.colorizer[\"continuous\"]) {\n        var anchor_format = d3.format(\",.4r\");\n        var scale = graph_data[_networkGraphAttrbuteID][self.colorizer['category_id']]['scale'];\n\n        _.each(_.range(_networkContinuousColorStops), function(value) {\n          var x = scale.invert(value);\n          legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(20,\" + offset + \")\").append(\"text\").text(anchor_format(x));\n          legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(0,\" + offset + \")\").append(\"circle\").attr(\"cx\", \"8\")\n            .attr(\"cy\", \"-4\").attr(\"r\", \"8\").classed(\"legend\", true).style(\"fill\", self.colorizer['category'](x));\n\n          offset += 18;\n        });\n\n        legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(20,\" + offset + \")\").append(\"text\").text(\"missing\");\n        legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(0,\" + offset + \")\").append(\"circle\").attr(\"cx\", \"8\")\n          .attr(\"cy\", \"-4\").attr(\"r\", \"8\").classed(\"legend\", true).style(\"fill\", _networkMissingColor);\n\n        offset += 18;\n      } else {\n        _.each(self.colorizer['category_map'](null, 'map'), function(value, key) {\n          legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(20,\" + offset + \")\").append(\"text\").text(key);\n          legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(0,\" + offset + \")\").append(\"circle\").attr(\"cx\", \"8\").attr(\"cy\", \"-4\").attr(\"r\", \"8\").classed(\"legend\", true).style(\"fill\", self.colorizer['category'](key));\n\n          offset += 18;\n        });\n      }\n    }\n\n    if (self.node_shaper['id']) {\n      legend_svg.append(\"g\").attr(\"transform\", \"translate(0,\" + offset + \")\").classed('hiv-trace-legend', true).append(\"text\").text(\"Shape: \" + self.node_shaper['id']).style(\"font-weight\", \"bold\");\n      offset += 18;\n\n      var shape_mapper = d3.scale.ordinal().domain(_.range(0, graph_data[_networkGraphAttrbuteID][self.node_shaper['id']].dimension)).range(_networkShapeOrdering);\n\n      _.each(self.node_shaper['category_map'](null, 'map'), function(value, key) {\n        legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(20,\" + offset + \")\").append(\"text\").text(key);\n\n        legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(0,\" + offset + \")\").append(\"path\")\n          .attr(\"transform\", \"translate(5,-5)\")\n          .attr(\"d\", datamonkey.hivtrace.symbol(shape_mapper(value)).size(128))\n          .classed('legend', true)\n          .style('fill', 'none');\n\n        offset += 18;\n      });\n    }\n\n    if (self.colorizer['opacity_id']) {\n      legend_svg.append(\"g\").attr(\"transform\", \"translate(0,\" + offset + \")\").classed('hiv-trace-legend', true).append(\"text\").text(\"Opacity: \" + self.colorizer['opacity_id']).style(\"font-weight\", \"bold\");\n      offset += 18;\n\n      var anchor_format = d3.format(\",.4r\");\n      var scale = graph_data[_networkGraphAttrbuteID][self.colorizer['opacity_id']]['scale'];\n\n      _.each(_.range(_networkContinuousColorStops), function(value) {\n        var x = scale.invert(value);\n        legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(20,\" + offset + \")\").append(\"text\").text(anchor_format(x));\n        legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(0,\" + offset + \")\").append(\"circle\").attr(\"cx\", \"8\")\n          .attr(\"cy\", \"-4\").attr(\"r\", \"8\").classed(\"legend\", true).style(\"fill\", \"black\").style(\"opacity\", self.colorizer['opacity'](x));\n\n        offset += 18;\n      });\n\n      legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(20,\" + offset + \")\").append(\"text\").text(\"missing\");\n      legend_svg.append(\"g\").classed('hiv-trace-legend', true).attr(\"transform\", \"translate(0,\" + offset + \")\").append(\"circle\").attr(\"cx\", \"8\")\n        .attr(\"cy\", \"-4\").attr(\"r\", \"8\").classed(\"legend\", true).style(\"fill\", \"black\").style(\"opacity\", _networkMissingOpacity);\n\n      offset += 18;\n    }\n  }\n\n  function compute_cluster_gradient(cluster, cat_id) {\n    if (cat_id) {\n      var id = \"hivtrace-cluster-gradient-\" + (self.gradient_id++);\n      var gradient = network_svg.selectAll(\"defs\").append(\"radialGradient\").attr(\"id\", id);\n      var values = _.map(cluster.children, function(node) {\n        var value = attribute_node_value_by_id(node, cat_id);\n        return value == _networkMissing ? Infinity : value;\n      }).sort(function(a, b) {\n        return (0 + a) - (0 + b);\n      });\n      var finite = _.filter(values, function(d) {\n        return d < Infinity;\n      });\n      var infinite = values.length - finite.length;\n\n\n      if (infinite) {\n        gradient.append(\"stop\").attr(\"offset\", \"0%\").attr(\"stop-color\", _networkMissingColor);\n        gradient.append(\"stop\").attr(\"offset\", \"\" + (infinite / values.length * 100) + \"%\").attr(\"stop-color\", _networkMissingColor);\n      }\n\n\n      _.each(finite, function(value, index) {\n        gradient.append(\"stop\").attr(\"offset\", \"\" + ((1 + index + infinite) * 100) / values.length + \"%\").attr(\"stop-color\", self.colorizer['category'](value));\n      });\n      //gradient.append (\"stop\").attr (\"offset\", \"100%\").attr (\"stop-color\", self.colorizer['category'] (dom[1]));\n\n\n      return id;\n    }\n    return null;\n  }\n\n  function handle_attribute_opacity(cat_id) {\n    var set_attr = \"None\";\n\n    [\"#\" + button_bar_ui + \"_opacity\"].forEach(function(m) {\n      d3.select(m).selectAll(\"li\").selectAll(\"a\").attr(\"style\", function(d, i) {\n        if (d[1] == cat_id) {\n          set_attr = d[0];\n          return ' font-weight: bold;'\n        };\n        return null;\n      });\n      d3.select(m + \"_label\").html(\"Opacity: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n    d3.select(\"#\" + button_bar_ui + \"_opacity_invert\").style(\"display\", set_attr == \"None\" ? \"none\" : \"inline\").classed(\"btn-active\", false).classed(\"btn-default\", true);\n\n\n\n    self.colorizer['opacity_id'] = cat_id;\n    if (cat_id) {\n      var scale = graph_data[_networkGraphAttrbuteID][cat_id]['scale'];\n      self.colorizer['opacity_scale'] = d3.scale.linear().domain([0, _networkContinuousColorStops - 1]).range([0.25, 1]);\n      self.colorizer['opacity'] = function(v) {\n        if (v == _networkMissing) {\n          return _networkMissingOpacity;\n        }\n        return self.colorizer['opacity_scale'](scale(v));\n      };\n    } else {\n      self.colorizer['opacity'] = null;\n      self.colorizer['opacity_scale'] = null;\n    }\n\n\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n  }\n\n  function handle_attribute_continuous(cat_id) {\n    var set_attr = \"None\";\n\n    render_chord_diagram(\"#\" + button_bar_ui + \"_aux_svg_holder\", null, null);\n    render_binned_table(\"#\" + button_bar_ui + \"_attribute_table\", null, null);\n\n    network_svg.selectAll(\"radialGradient\").remove();\n\n    self.clusters.forEach(function(the_cluster) {\n      delete the_cluster['binned_attributes'];\n      delete the_cluster[\"gradient\"]\n    });\n\n    [\"#\" + button_bar_ui + \"_attributes\", \"#\" + button_bar_ui + \"_attributes_cat\"].forEach(function(m) {\n      d3.select(m).selectAll(\"li\").selectAll(\"a\").attr(\"style\", function(d, i) {\n        if (d[1] == cat_id) {\n          set_attr = d[0];\n          return ' font-weight: bold;'\n        };\n        return null;\n      });\n      d3.select(m + \"_label\").html(\"Color: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n    d3.select(\"#\" + button_bar_ui + \"_attributes_invert\").style(\"display\", set_attr == \"None\" ? \"none\" : \"inline\").classed(\"btn-active\", false).classed(\"btn-default\", true);\n\n    if (cat_id) {\n      //console.log (graph_data [_networkGraphAttrbuteID][cat_id]);\n\n\n      self.colorizer['category'] = _.wrap(d3.scale.linear().range([\"#fff7ec\", \"#fee8c8\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#ef6548\", \"#d7301f\", \"#b30000\", \"#7f0000\"]).domain(_.range(_networkContinuousColorStops)),\n        function(func, arg) {\n          return func(graph_data[_networkGraphAttrbuteID][cat_id]['scale'](arg));\n        }); //console.log (self.colorizer['category'].exponent ());\n\n      //console.log (self.colorizer['category'] (graph_data [_networkGraphAttrbuteID][cat_id]['value_range'][0]), self.colorizer['category'] (d['value_range'][1]));\n\n      self.colorizer['category_id'] = cat_id;\n      self.colorizer['continuous'] = true;\n      self.clusters.forEach(function(the_cluster) {\n        the_cluster[\"gradient\"] = compute_cluster_gradient(the_cluster, cat_id);\n      });\n\n\n      var points = [];\n\n      _.each(self.edges, function(e) {\n\n\n        var src = attribute_node_value_by_id(self.nodes[e.source], cat_id),\n          tgt = attribute_node_value_by_id(self.nodes[e.target], cat_id);\n\n        if (src != _networkMissing && tgt != _networkMissing) {\n          points.push({\n            x: src,\n            y: tgt,\n            title: self.nodes[e.source].id + \" (\" + src + \") -- \" + self.nodes[e.target].id + \" (\" + tgt + \")\"\n          });\n        }\n      });\n\n      datamonkey.hivtrace.scatterplot(points, 400, 400, \"#\" + button_bar_ui + \"_aux_svg_holder\", {\n        x: \"Source\",\n        y: \"Target\"\n      });\n\n    } else {\n      self.colorizer['category'] = null;\n      self.colorizer['category_id'] = null;\n      self.colorizer['continuous'] = false;\n      self.colorizer['category_pairwise'] = null;\n      self.colorizer['category_map'] = null;\n    }\n\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n\n  }\n\n  function handle_attribute_categorical(cat_id) {\n\n    console.log(\"handling categorical attributes\");\n\n    //console.log (cat_id, graph_data [_networkGraphAttrbuteID]);\n\n    var set_attr = \"None\";\n    d3.select(\"#\" + button_bar_ui + \"_attributes_invert\").style(\"display\", \"none\");\n\n    network_svg.selectAll(\"radialGradient\").remove();\n\n    [\"#\" + button_bar_ui + \"_attributes\", \"#\" + button_bar_ui + \"_attributes_cat\"].forEach(function(m) {\n      d3.select(m).selectAll(\"li\").selectAll(\"a\").attr(\"style\", function(d, i) {\n        if (d[1] == cat_id) {\n          set_attr = d[0];\n          return ' font-weight: bold;'\n        };\n        return null;\n      });\n      d3.select(m + \"_label\").html(\"Color: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n    self.clusters.forEach(function(the_cluster) {\n      delete the_cluster[\"gradient\"];\n      the_cluster['binned_attributes'] = stratify(attribute_cluster_distribution(the_cluster, cat_id));\n    });\n\n\n    self.colorizer['continuous'] = false;\n\n    if (cat_id) {\n      if (cat_id in _networkPresetColorSchemes) {\n        var domain = [],\n          range = [];\n        _.each(_networkPresetColorSchemes[cat_id], function(value, key) {\n          domain.push(key);\n          range.push(value);\n        });\n        self.colorizer['category'] = d3.scale.ordinal().domain(domain).range(range);\n\n      } else {\n        if (graph_data[_networkGraphAttrbuteID][cat_id]['color_scale']) {\n          self.colorizer['category'] = graph_data[_networkGraphAttrbuteID][cat_id]['color_scale'](graph_data[_networkGraphAttrbuteID][cat_id]);\n        } else {\n          self.colorizer['category'] = graph_data[_networkGraphAttrbuteID][cat_id].dimension <= 10 ? d3.scale.category10() : d3.scale.category20c();\n        }\n      }\n      self.colorizer['category_id'] = cat_id;\n      self.colorizer['category_map'] = graph_data[_networkGraphAttrbuteID][cat_id]['value_map'];\n      //self.colorizer['category_map'][null] =  graph_data [_networkGraphAttrbuteID][cat_id]['range'];\n      self.colorizer['category_pairwise'] = attribute_pairwise_distribution(cat_id, graph_data[_networkGraphAttrbuteID][cat_id].dimension, self.colorizer['category_map']);\n\n\n\n      render_chord_diagram(\"#\" + button_bar_ui + \"_aux_svg_holder\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\n      render_binned_table(\"#\" + button_bar_ui + \"_attribute_table\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\n    } else {\n      self.colorizer['category'] = null;\n      self.colorizer['category_id'] = null;\n      self.colorizer['category_pairwise'] = null;\n      self.colorizer['category_map'] = null;\n      render_chord_diagram(\"#\" + button_bar_ui + \"_aux_svg_holder\", null, null);\n      render_binned_table(\"#\" + button_bar_ui + \"_attribute_table\", null, null);\n    }\n\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n  }\n\n  self.filter = function(expressions, skip_update) {\n\n    var anything_changed = false;\n\n    self.clusters.forEach(function(c) {\n      c.match_filter = 0;\n    });\n\n    self.nodes.forEach(function(n) {\n      var did_match = _.some(expressions, function(regexp) {\n        return regexp.test(n.id) || _.some(n[_networkNodeAttributeID], function(attr) {\n          return regexp.test(attr)\n        });\n      });\n\n      if (did_match != n.match_filter) {\n        n.match_filter = did_match;\n        anything_changed = true;\n      }\n\n      if (n.match_filter) {\n        n.parent.match_filter += 1;\n      }\n    });\n\n\n    if (anything_changed && !skip_update) {\n      self.update(true);\n    }\n\n  }\n\n  self.update = function(soft, friction) {\n\n    self.needs_an_update = false;\n\n    if (friction) {\n      network_layout.friction(friction);\n    }\n    if (network_warning_tag) {\n      if (warning_string.length) {\n        d3.select(network_warning_tag).text(warning_string).style(\"display\", \"block\");\n        warning_string = \"\";\n      } else {\n        d3.select(network_warning_tag).style(\"display\", \"none\");\n      }\n    }\n\n    var rendered_nodes,\n      rendered_clusters,\n      link;\n\n    if (!soft) {\n\n      var draw_me = prepare_data_to_graph();\n\n\n      network_layout.nodes(draw_me.all)\n        .links(draw_me.edges)\n        .start();\n\n      update_network_string(draw_me);\n\n      link = network_svg.selectAll(\".link\")\n        .data(draw_me.edges, function(d) {\n          return d.id;\n        });\n\n      link.enter().append(\"line\")\n        .classed(\"link\", true);\n      link.exit().remove();\n\n      link.classed(\"removed\", function(d) {\n          return d.removed;\n        })\n        .classed(\"unsupported\", function(d) {\n          return \"support\" in d && d[\"support\"] > 0.05;\n        })\n        .on(\"mouseover\", edge_pop_on)\n        .on(\"mouseout\", edge_pop_off)\n        .filter(function(d) {\n          return d.directed;\n        })\n        .attr(\"marker-end\", \"url(#arrowhead)\");\n\n\n      rendered_nodes = network_svg.selectAll('.node')\n        .data(draw_me.nodes, function(d) {\n          return d.id;\n        });\n      rendered_nodes.exit().remove();\n      rendered_nodes.enter().append(\"path\");\n\n      rendered_clusters = network_svg.selectAll(\".cluster-group\").\n      data(draw_me.clusters.map(function(d) {\n        return d;\n      }), function(d) {\n        return d.cluster_id;\n      });\n\n      rendered_clusters.exit().remove();\n      rendered_clusters.enter().append(\"g\").attr(\"class\", \"cluster-group\")\n        .attr(\"transform\", function(d) {\n          return \"translate(\" + d.x + \",\" + d.y + \")\";\n        })\n        .on(\"click\", handle_cluster_click)\n        .on(\"mouseover\", cluster_pop_on)\n        .on(\"mouseout\", cluster_pop_off)\n        .call(network_layout.drag().on(\"dragstart\", cluster_pop_off));\n\n      draw_cluster_table();\n      draw_node_table();\n\n    } else {\n      rendered_nodes = network_svg.selectAll('.node');\n      rendered_clusters = network_svg.selectAll(\".cluster-group\");\n      link = network_svg.selectAll(\".link\");\n    }\n\n    rendered_nodes.each(function(d) {\n      draw_a_node(this, d);\n    });\n\n    rendered_clusters.each(function(d) {\n      draw_a_cluster(this, d);\n    });\n\n    link.style(\"opacity\", function(d) {\n      return Math.max(node_opacity(d.target), node_opacity(d.source))\n    })\n\n\n    if (!soft) {\n      currently_displayed_objects = rendered_clusters[0].length + rendered_nodes[0].length;\n\n      network_layout.on(\"tick\", function() {\n        var sizes = network_layout.size();\n\n        rendered_nodes.attr(\"transform\", function(d) {\n          return \"translate(\" + (d.x = Math.max(10, Math.min(sizes[0] - 10, d.x))) + \",\" + (d.y = Math.max(10, Math.min(sizes[1] - 10, d.y))) + \")\";\n        });\n        rendered_clusters.attr(\"transform\", function(d) {\n          return \"translate(\" + (d.x = Math.max(10, Math.min(sizes[0] - 10, d.x))) + \",\" + (d.y = Math.max(10, Math.min(sizes[1] - 10, d.y))) + \")\";\n        });\n\n        link.attr(\"x1\", function(d) {\n            return d.source.x;\n          })\n          .attr(\"y1\", function(d) {\n            return d.source.y;\n          })\n          .attr(\"x2\", function(d) {\n            return d.target.x;\n          })\n          .attr(\"y2\", function(d) {\n            return d.target.y;\n          });\n      });\n    } else {\n      link.each(function(d) {\n        d3.select(this).attr(\"x1\", function(d) {\n            return d.source.x;\n          })\n          .attr(\"y1\", function(d) {\n            return d.source.y;\n          })\n          .attr(\"x2\", function(d) {\n            return d.target.x;\n          })\n          .attr(\"y2\", function(d) {\n            return d.target.y;\n          })\n      });\n    }\n  }\n\n  function tick() {\n    var sizes = network_layout.size();\n\n    node.attr(\"cx\", function(d) {\n        return d.x = Math.max(10, Math.min(sizes[0] - 10, d.x));\n      })\n      .attr(\"cy\", function(d) {\n        return d.y = Math.max(10, Math.min(sizes[1] - 10, d.y));\n      });\n\n    link.attr(\"x1\", function(d) {\n        return d.source.x;\n      })\n      .attr(\"y1\", function(d) {\n        return d.source.y;\n      })\n      .attr(\"x2\", function(d) {\n        return d.target.x;\n      })\n      .attr(\"y2\", function(d) {\n        return d.target.y;\n      });\n\n  }\n\n  /*------------ Node Methods ---------------*/\n  function compute_node_degrees(nodes, edges) {\n    for (var n in nodes) {\n      nodes[n].degree = 0;\n    }\n\n    for (var e in edges) {\n      nodes[edges[e].source].degree++;\n      nodes[edges[e].target].degree++;\n    }\n  }\n\n  function attribute_node_value_by_id(d, id) {\n    if (_networkNodeAttributeID in d && id) {\n      if (id in d[_networkNodeAttributeID]) {\n        var v = d[_networkNodeAttributeID][id];\n        if (_.isString(v) && v.length == 0) {\n          return _networkMissing;\n        }\n        return v;\n      }\n    }\n    return _networkMissing;\n  }\n\n  function inject_attribute_node_value_by_id(d, id, value) {\n    if (_networkNodeAttributeID in d && id) {\n      d[_networkNodeAttributeID][id] = value;\n    }\n  }\n\n  function node_size(d) {\n    var r = 5 + Math.sqrt(d.degree); //return (d.match_filter ? 10 : 4)*r*r;\n    return 4 * r * r;\n  }\n\n  function node_color(d) {\n\n    /*if (d.match_filter) {\n        return \"white\";\n    }*/\n\n    if (self.colorizer['category_id']) {\n      var v = attribute_node_value_by_id(d, self.colorizer['category_id']);\n      if (self.colorizer['continuous']) {\n        if (v == _networkMissing) {\n          return _networkMissingColor;\n        }\n      }\n      return self.colorizer['category'](v);\n\n    }\n    return d.hxb2_linked ? \"black\" : (d.is_lanl ? \"red\" : \"gray\");\n  }\n\n  function node_opacity(d) {\n    if (self.colorizer['opacity']) {\n      return self.colorizer['opacity'](attribute_node_value_by_id(d, self.colorizer['opacity_id']));\n    }\n    return 1.;\n  }\n\n  function cluster_color(d, type) {\n    if (d[\"binned_attributes\"]) {\n      return self.colorizer['category'](type);\n    }\n    return \"#bdbdbd\";\n  }\n\n  function hxb2_node_color(d) {\n    return \"black\";\n  }\n\n  function node_info_string(n) {\n    var str;\n\n    if (!_is_CDC_) {\n      str = \"Degree <em>\" + n.degree + \"</em><br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value(n.lcc, _defaultFloatFormat) + \"</em>\";\n    } else {\n      str = \"# links <em>\" + n.degree + \"</em>\";\n    }\n\n\n    _.each([self.colorizer['category_id'], self.node_shaper['id'], self.colorizer['opacity_id']],\n      function(key) {\n        if (key) {\n          var attribute = attribute_node_value_by_id(n, key);\n          if (attribute) {\n            str += \"<br>\" + key + \" <em>\" + attribute + \"</em>\"\n          }\n\n        }\n      });\n\n\n    return str;\n  }\n\n  function edge_info_string(n) {\n    var str = \"Length <em>\" + _defaultFloatFormat(n.length) + \"</em>\";\n    if (\"support\" in n) {\n      str += \"<br>Worst triangle-based support (p): <em>\" + _defaultFloatFormat(n.support) + \"</em>\";\n    }\n\n    var attribute = attribute_node_value_by_id(n, self.colorizer['category_id']);\n\n    return str;\n  }\n\n  function node_pop_on(d) {\n    toggle_tooltip(this, true, (_is_CDC_ ? \"Individual \" : \"Node \") + d.id, node_info_string(d), self.container);\n  }\n\n  function node_pop_off(d) {\n    toggle_tooltip(this, false);\n  }\n\n  function edge_pop_on(e) {\n    toggle_tooltip(this, true, e.source.id + \" - \" + e.target.id, edge_info_string(e), self.container);\n  }\n\n  function edge_pop_off(d) {\n    toggle_tooltip(this, false);\n  }\n\n  /*------------ Cluster Methods ---------------*/\n\n  function compute_cluster_centroids(clusters) {\n    for (var c in clusters) {\n      var cls = clusters[c];\n      cls.x = 0.;\n      cls.y = 0.;\n      cls.children.forEach(function(x) {\n        cls.x += x.x;\n        cls.y += x.y;\n      });\n      cls.x /= cls.children.length;\n      cls.y /= cls.children.length;\n    }\n  }\n\n  function collapse_cluster(x, keep_in_q) {\n    self.needs_an_update = true;\n    x.collapsed = true;\n    currently_displayed_objects -= self.cluster_sizes[x.cluster_id - 1] - 1;\n    if (!keep_in_q) {\n      var idx = open_cluster_queue.indexOf(x.cluster_id);\n      if (idx >= 0) {\n        open_cluster_queue.splice(idx, 1);\n      }\n    }\n    compute_cluster_centroids([x]);\n    return x.children.length;\n  }\n\n  function expand_cluster(x, copy_coord) {\n    self.needs_an_update = true;\n    x.collapsed = false;\n    currently_displayed_objects += self.cluster_sizes[x.cluster_id - 1] - 1;\n    open_cluster_queue.push(x.cluster_id);\n    if (copy_coord) {\n      x.children.forEach(function(n) {\n        n.x = x.x + (Math.random() - 0.5) * x.children.length;\n        n.y = x.y + (Math.random() - 0.5) * x.children.length;\n      });\n    } else {\n      x.children.forEach(function(n) {\n        n.x = self.width * 0.25 + (Math.random() - 0.5) * x.children.length;\n        n.y = 0.25 * self.height + (Math.random() - 0.5) * x.children.length;\n      })\n    }\n  }\n\n  function render_binned_table(id, the_map, matrix) {\n\n    var the_table = d3.select(id);\n\n    the_table.selectAll(\"thead\").remove();\n    the_table.selectAll(\"tbody\").remove();\n\n    if (matrix) {\n\n      var fill = self.colorizer['category'];\n      lookup = the_map(null, 'lookup');\n\n\n      var headers = the_table.append(\"thead\").append(\"tr\")\n        .selectAll(\"th\").data([\"\"].concat(matrix[0].map(function(d, i) {\n          return lookup[i];\n        })));\n\n      headers.enter().append(\"th\");\n      headers.html(function(d) {\n        return \"<span>&nbsp;\" + d + \"</span>\";\n      }).each(\n        function(d, i) {\n          if (i) {\n            d3.select(this).insert(\"i\", \":first-child\")\n              .classed(\"fa fa-circle\", true)\n              .style(\"color\", function() {\n                return fill(d);\n              });\n          }\n        }\n      );\n\n      var rows = the_table.append(\"tbody\").selectAll(\"tr\").data(matrix.map(function(d, i) {\n        return [lookup[i]].concat(d);\n      }));\n      rows.enter().append(\"tr\");\n      rows.selectAll(\"td\").data(function(d) {\n        return d\n      }).enter().append(\"td\").html(function(d, i) {\n        return i == 0 ? (\"<span>&nbsp;\" + d + \"</span>\") : d;\n      }).each(function(d, i) {\n        if (i == 0) {\n          d3.select(this).insert(\"i\", \":first-child\")\n            .classed(\"fa fa-circle\", true)\n            .style(\"color\", function() {\n              return fill(d);\n            });\n        }\n\n      });\n\n\n\n    }\n  }\n\n  function render_chord_diagram(id, the_map, matrix) {\n\n    d3.select(id).selectAll(\"svg\").remove();\n    if (matrix) {\n\n      lookup = the_map(null, 'lookup');\n\n\n      var svg = d3.select(id).append(\"svg\");\n\n\n      var chord = d3.layout.chord()\n        .padding(.05)\n        .sortSubgroups(d3.descending)\n        .matrix(matrix);\n\n      var text_offset = 20,\n        width = 450,\n        height = 450,\n        innerRadius = Math.min(width, height - text_offset) * .41,\n        outerRadius = innerRadius * 1.1;\n\n      var fill = self.colorizer['category'],\n        font_size = 12;\n\n\n\n      var text_label = svg.append(\"g\")\n        .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height - text_offset) + \")\")\n        .append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", font_size)\n        .text(\"\");\n\n      svg = svg.attr(\"width\", width)\n        .attr(\"height\", height - text_offset)\n        .append(\"g\")\n        .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height - text_offset) / 2 + \")\");\n\n\n      svg.append(\"g\").selectAll(\"path\")\n        .data(chord.groups)\n        .enter().append(\"path\")\n        .style(\"fill\", function(d) {\n          return fill(lookup[d.index]);\n        })\n        .style(\"stroke\", function(d) {\n          return fill(lookup[d.index]);\n        })\n        .attr(\"d\", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius))\n        .on(\"mouseover\", fade(0.1, true))\n        .on(\"mouseout\", fade(1, false));\n\n\n\n      svg.append(\"g\")\n        .attr(\"class\", \"chord\")\n        .selectAll(\"path\")\n        .data(chord.chords)\n        .enter().append(\"path\")\n        .attr(\"d\", d3.svg.chord().radius(innerRadius))\n        .style(\"fill\", function(d) {\n          return fill(d.target.index);\n        })\n        .style(\"opacity\", 1);\n\n      // Returns an event handler for fading a given chord group.\n      function fade(opacity, t) {\n        return function(g, i) {\n          text_label.text(t ? lookup[i] : \"\");\n          svg.selectAll(\".chord path\")\n            .filter(function(d) {\n              return d.source.index != i && d.target.index != i;\n            })\n            .transition()\n            .style(\"opacity\", opacity);\n        };\n      }\n    }\n  }\n\n  function attribute_pairwise_distribution(id, dim, the_map, only_expanded) {\n    var scan_from = only_expanded ? draw_me.edges : self.edges;\n    var the_matrix = [];\n    for (i = 0; i < dim; i += 1) {\n      the_matrix.push([]);\n      for (j = 0; j < dim; j += 1) {\n        the_matrix[i].push(0);\n      }\n    }\n\n\n    _.each(scan_from,\n      function(edge) {\n        the_matrix[the_map(attribute_node_value_by_id(self.nodes[edge.source], id))][the_map(attribute_node_value_by_id(self.nodes[edge.target], id))] += 1;\n      });\n    // check if there are null values\n\n    var haz_null = the_matrix.some(function(d, i) {\n      if (i == dim - 1) {\n        return d.some(function(d2) {\n          return d2 > 0;\n        });\n      }\n      return d[dim - 1] > 0;\n    });\n    if (!haz_null) {\n      the_matrix.pop();\n      for (i = 0; i < dim - 1; i += 1) {\n        the_matrix[i].pop();\n      }\n    }\n\n    return the_matrix;\n  }\n\n  function attribute_cluster_distribution(the_cluster, attribute_id) {\n    if (attribute_id && the_cluster) {\n      return the_cluster.children.map(function(d) {\n        return attribute_node_value_by_id(d, attribute_id);\n      });\n    }\n    return null;\n  }\n\n  function cluster_info_string(id) {\n    var the_cluster = self.clusters[id - 1],\n      attr_info = the_cluster[\"binned_attributes\"];\n\n\n\n    var str;\n\n    if (_is_CDC_) {\n      str = \"<strong>\" + self.cluster_sizes[id - 1] + \"</strong> individuals.\" +\n        \"<br>Mean links/individual <em> = \" + _defaultFloatFormat(the_cluster.degrees['mean']) + \"</em>\" +\n        \"<br>Max links/individual <em> = \" + the_cluster.degrees['max'] + \"</em>\";\n    } else {\n      str = \"<strong>\" + self.cluster_sizes[id - 1] + \"</strong> nodes.\" +\n        \"<br>Mean degree <em>\" + _defaultFloatFormat(the_cluster.degrees['mean']) + \"</em>\" +\n        \"<br>Max degree <em>\" + the_cluster.degrees['max'] + \"</em>\" +\n        \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value(the_cluster.cc, _defaultFloatFormat) + \"</em>\";\n    }\n\n    if (attr_info) {\n      attr_info.forEach(function(d) {\n        str += \"<br>\" + d[0] + \" <em>\" + d[1] + \"</em>\"\n      });\n    }\n\n    return str;\n  }\n\n  function cluster_pop_on(d) {\n    toggle_tooltip(this, true, \"Cluster \" + d.cluster_id, cluster_info_string(d.cluster_id), self.container);\n  }\n\n  function cluster_pop_off(d) {\n    toggle_tooltip(this, false);\n  }\n\n  function expand_cluster_handler(d, do_update, move_out) {\n    if (d.collapsed) {\n      var new_nodes = self.cluster_sizes[d.cluster_id - 1] - 1;\n\n      if (new_nodes > max_points_to_render) {\n        warning_string = \"This cluster is too large to be displayed\";\n      } else {\n        var leftover = new_nodes + currently_displayed_objects - max_points_to_render;\n        if (leftover > 0) {\n          for (k = 0; k < open_cluster_queue.length && leftover > 0; k++) {\n            var cluster = self.clusters[cluster_mapping[open_cluster_queue[k]]];\n            leftover -= cluster.children.length - 1;\n            collapse_cluster(cluster, true);\n          }\n          if (k || open_cluster_queue.length) {\n            open_cluster_queue.splice(0, k);\n          }\n        }\n\n        if (leftover <= 0) {\n          expand_cluster(d, !move_out);\n        }\n      }\n\n      if (do_update) {\n        self.update(false, 0.6);\n      }\n    }\n    return \"\";\n  }\n\n  function collapse_cluster_handler(d, do_update) {\n    collapse_cluster(self.clusters[cluster_mapping[d.cluster]]);\n    if (do_update) {\n      self.update(false, 0.4);\n    }\n\n  }\n\n  function center_cluster_handler(d) {\n    d.x = self.width / 2;\n    d.y = self.height / 2;\n    self.update(false, 0.4);\n  }\n\n  function cluster_box_size(c) {\n    return 8 * Math.sqrt(c.children.length);\n  }\n\n  self.expand_some_clusters = function(subset) {\n    subset = subset || self.clusters;\n    subset.forEach(function(x) {\n      expand_cluster_handler(x, false);\n    });\n    self.update();\n  }\n\n  self.select_some_clusters = function(condition) {\n    return self.clusters.filter(function(c, i) {\n      return _.some(c.children, (function(n) {\n        return condition(n);\n      }));\n    });\n  }\n\n  self.collapse_some_clusters = function(subset) {\n    subset = subset || self.clusters;\n    subset.forEach(function(x) {\n      if (!x.collapsed) collapse_cluster(x);\n    });\n    self.update();\n  }\n\n  self.toggle_hxb2 = function() {\n    self.hide_hxb2 = !self.hide_hxb2;\n    self.update();\n  }\n\n  $('#reset_layout').click(function(e) {\n    default_layout(clusters, nodes);\n    self.update();\n    e.preventDefault(); // prevent the default anchor functionality\n  });\n\n  function stratify(array) {\n    if (array) {\n      var dict = {},\n        stratified = [];\n\n      array.forEach(function(d) {\n        if (d in dict) {\n          dict[d] += 1;\n        } else {\n          dict[d] = 1;\n        }\n      });\n      for (var uv in dict) {\n        stratified.push([uv, dict[uv]]);\n      }\n      return stratified.sort(function(a, b) {\n        return a[0] - b[0];\n      });\n    }\n    return array;\n  }\n\n  /*------------ Event Functions ---------------*/\n  function toggle_tooltip(element, turn_on, title, tag, container) {\n    //if (d3.event.defaultPrevented) return;\n\n    if (turn_on && !element.tooltip) {\n\n      // check to see if there are any other tooltips shown\n      ($(\"[role='tooltip']\")).each(function(d) {\n        $(this).remove();\n      });\n\n      var this_box = $(element);\n      var this_data = d3.select(element).datum();\n      element.tooltip = this_box.tooltip({\n        title: title + \"<br>\" + tag,\n        html: true,\n        container: container ? container : 'body',\n      });\n\n      //this_data.fixed = true;\n\n      _.delay(_.bind(element.tooltip.tooltip, element.tooltip), 500, 'show');\n    } else {\n      if (turn_on == false && element.tooltip) {\n        element.tooltip.tooltip('destroy');\n        element.tooltip = undefined;\n      }\n    }\n  }\n\n  initial_json_load();\n  if (options) {\n    if (_.isNumber(options[\"charge\"])) {\n      self.charge_correction = options[\"charge\"];\n    }\n\n    if (\"colorizer\" in options) {\n      self.colorizer = options[\"colorizer\"];\n    }\n\n    if (\"node_shaper\" in options) {\n      self.node_shaper = options[\"node_shaper\"];\n    }\n\n    draw_attribute_labels();\n    network_layout.start();\n\n    if (_.isArray(options[\"expand\"])) {\n      self.expand_some_clusters(_.filter(self.clusters, function(c) {\n        console.log(c);\n        return options[\"expand\"].indexOf(c.cluster_id) >= 0;\n      }));\n    }\n  }\n  return self;\n}\n\nvar hivtrace_cluster_graph_summary = function(graph, tag) {\n\n  var summary_table = d3.select(tag).append(\"tbody\");\n\n  var table_data = [];\n\n  if (!summary_table.empty()) {\n    _.each(graph[\"Network Summary\"], function(value, key) {\n      table_data.push([key, value]);\n    });\n  }\n\n  var degrees = [];\n  _.each(graph[\"Degrees\"][\"Distribution\"], function(value, index) {\n    for (k = 0; k < value; k++) {\n      degrees.push(index + 1);\n    }\n  });\n  degrees = datamonkey.helpers.describe_vector(degrees);\n  table_data.push(['Links/node', '']);\n  table_data.push(['&nbsp;&nbsp;<i>Mean</i>', _defaultFloatFormat(degrees['mean'])]);\n  table_data.push(['&nbsp;&nbsp;<i>Median</i>', _defaultFloatFormat(degrees['median'])]);\n  table_data.push(['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\n  table_data.push(['&nbsp;&nbsp;<i>Interquartile range</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\n\n  degrees = datamonkey.helpers.describe_vector(graph[\"Cluster sizes\"]);\n  table_data.push(['Cluster sizes', '']);\n  table_data.push(['&nbsp;&nbsp;<i>Mean</i>', _defaultFloatFormat(degrees['mean'])]);\n  table_data.push(['&nbsp;&nbsp;<i>Median</i>', _defaultFloatFormat(degrees['median'])]);\n  table_data.push(['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\n  table_data.push(['&nbsp;&nbsp;<i>Interquartile range</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\n\n  if (_is_CDC_) {\n    degrees = datamonkey.helpers.describe_vector(_.map(graph[\"Edges\"], function(e) {\n      return e.length;\n    }));\n    table_data.push(['Genetic distances (links only)', '']);\n    table_data.push(['&nbsp;&nbsp;<i>Mean</i>', _defaultPercentFormat(degrees['mean'])]);\n    table_data.push(['&nbsp;&nbsp;<i>Median</i>', _defaultPercentFormat(degrees['median'])]);\n    table_data.push(['&nbsp;&nbsp;<i>Range</i>', _defaultPercentFormat(degrees['min']) + \" - \" + _defaultPercentFormat(degrees['max'])]);\n    table_data.push(['&nbsp;&nbsp;<i>Interquartile range</i>', _defaultPercentFormat(degrees['Q1']) + \" - \" + _defaultPercentFormat(degrees['Q3'])]);\n\n  }\n\n\n  summary_table.selectAll(\"tr\").data(table_data).enter().append(\"tr\").selectAll(\"td\").data(function(d) {\n    return d;\n  }).enter().append(\"td\").html(function(d) {\n    return d\n  });\n}\n\ndatamonkey.hivtrace.cluster_network_graph = hivtrace_cluster_network_graph;\ndatamonkey.hivtrace.graph_summary = hivtrace_cluster_graph_summary;\n","\nfunction hivtrace_render_scatterplot(points, w, h, id, labels) {\n\n    var margin = {top: 10, right: 10, bottom: 70, left: 70},\n                width = w - margin.left - margin.right,\n                height = h - margin.top - margin.bottom;\n\n    var x = d3.scale.linear()\n            .domain(d3.extent (points, function (p) {return p.x;}))\n            .range([0, width]);\n\n    var y = d3.scale.linear()\n            .domain (d3.extent (points, function (p) {return p.y;}))\n            .range  ([height,0]);\n\n    var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient(\"bottom\").tickFormat (_defaultFloatFormat);\n\n    var yAxis = d3.svg.axis()\n        .scale(y)\n        .orient(\"left\").tickFormat (_defaultFloatFormat);\n\n\n\n    var histogram_svg = d3.select(id).selectAll(\"svg\");\n\n    if (!histogram_svg.empty()) {\n        histogram_svg.remove();\n    }\n\n    histogram_svg = d3.select(id).append (\"svg\").attr (\"width\", w).attr (\"height\", h).append (\"g\").attr (\"transform\", \"translate(\"  +  margin.left + \",\" + margin.top + \")\");\n\n    var points = histogram_svg.selectAll (\"circle\").data (points);\n    points.enter().append (\"circle\");\n\n    points.attr (\"cx\", function (d) {return x(d.x);}).attr (\"cy\", function (d) {return y (d.y);}).attr (\"r\", 3).classed (\"node scatter\", true);\n\n    points.each (function (d) {\n        if (\"title\" in d) {\n            d3.select (this).append (\"title\").text (d.title);\n        }\n    });\n\n     var x_axis = histogram_svg.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(xAxis);\n\n\n    x_axis.selectAll (\"text\").attr (\"transform\", \"rotate(-45)\").attr(\"dx\",\"-.5em\").attr(\"dy\",\".25em\").style (\"text-anchor\", \"end\");\n    x_axis.append (\"text\").text (labels.x).attr (\"transform\", \"translate(\" + width + \",0)\").attr (\"dy\", \"-1em\").attr (\"text-anchor\", \"end\");\n\n     var y_axis = histogram_svg.append(\"g\")\n        .attr(\"class\", \"y axis\")\n        .attr(\"transform\", \"translate(0,\" + 0 + \")\")\n        .call(yAxis);\n\n   y_axis.selectAll (\"text\").attr (\"transform\", \"rotate(-45)\").attr(\"dx\",\"-.5em\").attr(\"dy\",\".25em\").style (\"text-anchor\", \"end\");\n   y_axis.append (\"text\").text (labels.y).attr (\"transform\", \"rotate(-90)\").attr (\"dy\", \"1em\").attr (\"text-anchor\", \"end\");\n\n}\n\ndatamonkey.hivtrace.scatterplot = hivtrace_render_scatterplot;\n"],"sourceRoot":"/source/"}